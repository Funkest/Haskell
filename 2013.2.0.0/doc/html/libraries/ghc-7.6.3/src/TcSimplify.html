<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>typecheck\TcSimplify.lhs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
\begin{code}
<pre><a name="line-1"></a><span class='hs-comment'>{-# OPTIONS -fno-warn-tabs #-}</span>
<a name="line-2"></a><span class='hs-comment'>-- The above warning supression flag is a temporary kludge.</span>
<a name="line-3"></a><span class='hs-comment'>-- While working on this module you are encouraged to remove it and</span>
<a name="line-4"></a><span class='hs-comment'>-- detab the module (please do the detabbing in a separate patch). See</span>
<a name="line-5"></a><span class='hs-comment'>--     <a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#TabsvsSpaces">http://hackage.haskell.org/trac/ghc/wiki/Commentary/CodingStyle#TabsvsSpaces</a></span>
<a name="line-6"></a><span class='hs-comment'>-- for details</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>TcSimplify</span><span class='hs-layout'>(</span> 
<a name="line-9"></a>       <span class='hs-varid'>simplifyInfer</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyAmbiguityCheck</span><span class='hs-layout'>,</span>
<a name="line-10"></a>       <span class='hs-varid'>simplifyDefault</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyDeriv</span><span class='hs-layout'>,</span> 
<a name="line-11"></a>       <span class='hs-varid'>simplifyRule</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyTop</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyInteractive</span>
<a name="line-12"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-15"></a>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnMonad</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcErrors</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcMType</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcType</span> 
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcSMonad</span> 
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcInteract</span> 
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Inst</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Unify</span>	<span class='hs-layout'>(</span> <span class='hs-varid'>niFixTvSubst</span><span class='hs-layout'>,</span> <span class='hs-varid'>niSubstTvSet</span> <span class='hs-layout'>)</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>classifyPredType</span><span class='hs-layout'>,</span> <span class='hs-conid'>PredTree</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>isIPPred_maybe</span> <span class='hs-layout'>)</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Unique</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span> 
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcEvidence</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TypeRep</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Name</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Bag</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ListSetOps</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>PrelInfo</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>PrelNames</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Class</span>		<span class='hs-layout'>(</span> <span class='hs-varid'>classKey</span> <span class='hs-layout'>)</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span>       <span class='hs-layout'>(</span> <span class='hs-conid'>RuleName</span> <span class='hs-layout'>)</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>when</span> <span class='hs-layout'>)</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FastString</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TrieMap</span> <span class='hs-conid'>()</span> <span class='hs-comment'>-- DV: for now</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mapMaybe</span> <span class='hs-layout'>)</span>
</pre>\end{code}


*********************************************************************************
*                                                                               * 
*                           External interface                                  *
*                                                                               *
*********************************************************************************


\begin{code}
<pre><a name="line-1"></a>
<a name="line-2"></a>
<a name="line-3"></a><a name="simplifyTop"></a><span class='hs-definition'>simplifyTop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-4"></a><span class='hs-comment'>-- Simplify top-level constraints</span>
<a name="line-5"></a><span class='hs-comment'>-- Usually these will be implications,</span>
<a name="line-6"></a><span class='hs-comment'>-- but when there is nothing to quantify we don't wrap</span>
<a name="line-7"></a><span class='hs-comment'>-- in a degenerate implication, so we do that here instead</span>
<a name="line-8"></a><span class='hs-definition'>simplifyTop</span> <span class='hs-varid'>wanteds</span> 
<a name="line-9"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newTcEvBinds</span>
<a name="line-10"></a>                         
<a name="line-11"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_wanteds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkWC</span> <span class='hs-varid'>wanteds</span>
<a name="line-12"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wc_first_go</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>zonked_wanteds</span>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>cts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>applyTyVarDefaulting</span> <span class='hs-varid'>wc_first_go</span> 
<a name="line-14"></a>                <span class='hs-comment'>-- See Note [Top-level Defaulting Plan]</span>
<a name="line-15"></a>                
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>wc_for_loop</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wc_first_go</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wc_flat</span> <span class='hs-varid'>wc_first_go</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>cts</span> <span class='hs-layout'>}</span>
<a name="line-17"></a>                           
<a name="line-18"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simpl_top_loop {"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"zonked_wc ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_wanteds</span>
<a name="line-19"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>simpl_top_loop</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wc_for_loop</span> <span class='hs-layout'>}</span>
<a name="line-20"></a>    
<a name="line-21"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>simpl_top_loop</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wc</span>
<a name="line-22"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wc</span> 
<a name="line-23"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simpl_top_loop }"</span> <span class='hs-varid'>empty</span>
<a name="line-24"></a>               <span class='hs-layout'>;</span> <span class='hs-conid'>TcRnMonad</span><span class='hs-varop'>.</span><span class='hs-varid'>getTcEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-layout'>}</span>
<a name="line-25"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-26"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_residual</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wc</span>
<a name="line-27"></a>               <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>wc_flat_approximate</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>approximateWC</span> <span class='hs-varid'>wc_residual</span>
<a name="line-28"></a>               <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>dflt_eqs</span><span class='hs-layout'>,</span><span class='hs-sel'>_unused_bind</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcS</span> <span class='hs-varop'>$</span>
<a name="line-29"></a>                                            <span class='hs-varid'>applyDefaultingRules</span> <span class='hs-varid'>wc_flat_approximate</span>
<a name="line-30"></a>                                            <span class='hs-comment'>-- See Note [Top-level Defaulting Plan]</span>
<a name="line-31"></a>               <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>dflt_eqs</span> <span class='hs-keyword'>then</span> 
<a name="line-32"></a>                   <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simpl_top_loop }"</span> <span class='hs-varid'>empty</span>
<a name="line-33"></a>                      <span class='hs-layout'>;</span> <span class='hs-varid'>report_and_finish</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wc_residual</span> <span class='hs-layout'>}</span>
<a name="line-34"></a>                 <span class='hs-keyword'>else</span>
<a name="line-35"></a>                   <span class='hs-varid'>simpl_top_loop</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varop'>$</span> 
<a name="line-36"></a>                   <span class='hs-varid'>wc_residual</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wc_flat</span> <span class='hs-varid'>wc_residual</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>dflt_eqs</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-37"></a>
<a name="line-38"></a>        <span class='hs-varid'>report_and_finish</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wc_residual</span> 
<a name="line-39"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>eb1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcRnMonad</span><span class='hs-varop'>.</span><span class='hs-varid'>getTcEvBinds</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-40"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved {"</span> <span class='hs-varid'>empty</span>
<a name="line-41"></a>                   <span class='hs-comment'>-- See Note [Deferring coercion errors to runtime]</span>
<a name="line-42"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>runtimeCoercionErrors</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>doptM</span> <span class='hs-conid'>Opt_DeferTypeErrors</span>
<a name="line-43"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>eb2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>reportUnsolved</span> <span class='hs-varid'>runtimeCoercionErrors</span> <span class='hs-varid'>wc_residual</span>
<a name="line-44"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved }"</span> <span class='hs-varid'>empty</span>
<a name="line-45"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>eb1</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>eb2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}

Note [Top-level Defaulting Plan]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We have considered two design choices for where/when to apply defaulting.   
   (i) Do it in SimplCheck mode only /whenever/ you try to solve some 
       flat constraints, maybe deep inside the context of implications.
       This used to be the case in GHC 7.4.1.
   (ii) Do it in a tight loop at simplifyTop, once all other constraint has 
        finished. This is the current story.

Option (i) had many disadvantages: 
   a) First it was deep inside the actual solver, 
   b) Second it was dependent on the context (Infer a type signature, 
      or Check a type signature, or Interactive) since we did not want 
      to always start defaulting when inferring (though there is an exception to  
      this see Note [Default while Inferring])
   c) It plainly did not work. Consider typecheck/should_compile/DfltProb2.hs:
          f :: Int -> Bool
          f x = const True (\y -> let w :: a -> a
                                      w a = const a (y+1)
                                  in w y)
      We will get an implication constraint (for beta the type of y):
               [untch=beta] forall a. 0 => Num beta
      which we really cannot default /while solving/ the implication, since beta is
      untouchable.

Instead our new defaulting story is to pull defaulting out of the solver loop and
go with option (i), implemented at SimplifyTop. Namely:
     - First have a go at solving the residual constraint of the whole program
     - Try to approximate it with a flat constraint
     - Figure out derived defaulting equations for that flat constraint
     - Go round the loop again if you did manage to get some equations

Now, that has to do with class defaulting. However there exists type variable /kind/
defaulting. Again this is done at the top-level and the plan is:
     - At the top-level, once you had a go at solving the constraint, do 
       figure out /all/ the touchable unification variables of the wanted contraints.
     - Apply defaulting to their kinds

More details in Note [DefaultTyVar].

\begin{code}
<pre><a name="line-1"></a>
<a name="line-2"></a><a name="simplifyAmbiguityCheck"></a><span class='hs-comment'>------------------</span>
<a name="line-3"></a><span class='hs-definition'>simplifyAmbiguityCheck</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-4"></a><span class='hs-definition'>simplifyAmbiguityCheck</span> <span class='hs-varid'>name</span> <span class='hs-varid'>wanteds</span>
<a name="line-5"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyAmbiguityCheck"</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"name ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;</span> 
<a name="line-6"></a>    <span class='hs-varid'>simplifyTop</span> <span class='hs-varid'>wanteds</span>  <span class='hs-comment'>-- NB: must be simplifyTop not simplifyCheck, so that we</span>
<a name="line-7"></a>                         <span class='hs-comment'>--     do ambiguity resolution.  </span>
<a name="line-8"></a>                         <span class='hs-comment'>-- See Note [Impedence matching] in TcBinds.</span>
<a name="line-9"></a> 
<a name="line-10"></a><a name="simplifyInteractive"></a><span class='hs-comment'>------------------</span>
<a name="line-11"></a><span class='hs-definition'>simplifyInteractive</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-12"></a><span class='hs-definition'>simplifyInteractive</span> <span class='hs-varid'>wanteds</span> 
<a name="line-13"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInteractive"</span> <span class='hs-varid'>empty</span> <span class='hs-varop'>&gt;&gt;</span>
<a name="line-14"></a>    <span class='hs-varid'>simplifyTop</span> <span class='hs-varid'>wanteds</span> 
<a name="line-15"></a>
<a name="line-16"></a><a name="simplifyDefault"></a><span class='hs-comment'>------------------</span>
<a name="line-17"></a><span class='hs-definition'>simplifyDefault</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ThetaType</span>	<span class='hs-comment'>-- Wanted; has no type variables in it</span>
<a name="line-18"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>	<span class='hs-comment'>-- Succeeds iff the constraint is soluble</span>
<a name="line-19"></a><span class='hs-definition'>simplifyDefault</span> <span class='hs-varid'>theta</span>
<a name="line-20"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInteractive"</span> <span class='hs-varid'>empty</span>
<a name="line-21"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newFlatWanteds</span> <span class='hs-conid'>DefaultOrigin</span> <span class='hs-varid'>theta</span>
<a name="line-22"></a>       <span class='hs-layout'>;</span> <span class='hs-sel'>_ignored_ev_binds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplifyCheck</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkFlatWC</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-23"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-layout'>}</span>
</pre>\end{code}


***********************************************************************************
*                                                                                 * 
*                            Deriving                                             *
*                                                                                 *
***********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="simplifyDeriv"></a><span class='hs-definition'>simplifyDeriv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtOrigin</span>
<a name="line-2"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span>
<a name="line-3"></a>	      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span>	
<a name="line-4"></a>	      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span>		<span class='hs-comment'>-- Wanted</span>
<a name="line-5"></a>	      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>ThetaType</span>	<span class='hs-comment'>-- Needed</span>
<a name="line-6"></a><span class='hs-comment'>-- Given  instance (wanted) =&gt; C inst_ty </span>
<a name="line-7"></a><span class='hs-comment'>-- Simplify 'wanted' as much as possibles</span>
<a name="line-8"></a><span class='hs-comment'>-- Fail if not possible</span>
<a name="line-9"></a><span class='hs-definition'>simplifyDeriv</span> <span class='hs-varid'>orig</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> 
<a name="line-10"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>skol_subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>tvs_skols</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcInstSkolTyVars</span> <span class='hs-varid'>tvs</span> <span class='hs-comment'>-- Skolemize</span>
<a name="line-11"></a>      	 	<span class='hs-comment'>-- The constraint solving machinery </span>
<a name="line-12"></a>		<span class='hs-comment'>-- expects *TcTyVars* not TyVars.  </span>
<a name="line-13"></a>		<span class='hs-comment'>-- We use *non-overlappable* (vanilla) skolems</span>
<a name="line-14"></a>		<span class='hs-comment'>-- See Note [Overlap and deriving]</span>
<a name="line-15"></a>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>subst_skol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipTopTvSubst</span> <span class='hs-varid'>tvs_skols</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tvs</span>
<a name="line-17"></a>             <span class='hs-varid'>skol_set</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>tvs_skols</span>
<a name="line-18"></a>	     <span class='hs-varid'>doc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"deriving"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-19"></a>
<a name="line-20"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newFlatWanteds</span> <span class='hs-varid'>orig</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTheta</span> <span class='hs-varid'>skol_subst</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span>
<a name="line-21"></a>
<a name="line-22"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyDeriv"</span> <span class='hs-varop'>$</span> 
<a name="line-23"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>pprTvBndrs</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>theta</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>,</span> <span class='hs-varid'>doc</span> <span class='hs-keyglyph'>]</span>
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>residual_wanted</span><span class='hs-layout'>,</span> <span class='hs-sel'>_ev_binds1</span><span class='hs-layout'>)</span>
<a name="line-25"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWanteds</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkFlatWC</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-26"></a>
<a name="line-27"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>good</span><span class='hs-layout'>,</span> <span class='hs-varid'>bad</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBagWith</span> <span class='hs-varid'>get_good</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_flat</span> <span class='hs-varid'>residual_wanted</span><span class='hs-layout'>)</span>
<a name="line-28"></a>                         <span class='hs-comment'>-- See Note [Exotic derived instance contexts]</span>
<a name="line-29"></a>             <span class='hs-varid'>get_good</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-conid'>PredType</span> <span class='hs-conid'>Ct</span>
<a name="line-30"></a>             <span class='hs-varid'>get_good</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>validDerivPred</span> <span class='hs-varid'>skol_set</span> <span class='hs-varid'>p</span> 
<a name="line-31"></a>                         <span class='hs-layout'>,</span> <span class='hs-varid'>isWantedCt</span> <span class='hs-varid'>ct</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-varid'>p</span> 
<a name="line-32"></a>                         <span class='hs-comment'>-- NB: residual_wanted may contain unsolved</span>
<a name="line-33"></a>                         <span class='hs-comment'>-- Derived and we stick them into the bad set</span>
<a name="line-34"></a>                         <span class='hs-comment'>-- so that reportUnsolved may decide what to do with them</span>
<a name="line-35"></a>                         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>ct</span>
<a name="line-36"></a>                         <span class='hs-keyword'>where</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span>
<a name="line-37"></a>
<a name="line-38"></a>       <span class='hs-comment'>-- We never want to defer these errors because they are errors in the</span>
<a name="line-39"></a>       <span class='hs-comment'>-- compiler! Hence the `False` below</span>
<a name="line-40"></a>       <span class='hs-layout'>;</span> <span class='hs-sel'>_ev_binds2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>reportUnsolved</span> <span class='hs-conid'>False</span> <span class='hs-layout'>(</span><span class='hs-varid'>residual_wanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bad</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-41"></a>
<a name="line-42"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>min_theta</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkMinimalBySCs</span> <span class='hs-layout'>(</span><span class='hs-varid'>bagToList</span> <span class='hs-varid'>good</span><span class='hs-layout'>)</span>
<a name="line-43"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTheta</span> <span class='hs-varid'>subst_skol</span> <span class='hs-varid'>min_theta</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}

Note [Overlap and deriving]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider some overlapping instances:
  data Show a => Show [a] where ..
  data Show [Char] where ...

Now a data type with deriving:
  data T a = MkT [a] deriving( Show )

We want to get the derived instance
  instance Show [a] => Show (T a) where...
and NOT
  instance Show a => Show (T a) where...
so that the (Show (T Char)) instance does the Right Thing

It's very like the situation when we're inferring the type
of a function
   f x = show [x]
and we want to infer
   f :: Show [a] => a -> String

BOTTOM LINE: use vanilla, non-overlappable skolems when inferring
             the context for the derived instance. 
	     Hence tcInstSkolTyVars not tcInstSuperSkolTyVars

Note [Exotic derived instance contexts]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In a 'derived' instance declaration, we *infer* the context.  It's a
bit unclear what rules we should apply for this; the Haskell report is
silent.  Obviously, constraints like (Eq a) are fine, but what about
	data T f a = MkT (f a) deriving( Eq )
where we'd get an Eq (f a) constraint.  That's probably fine too.

One could go further: consider
	data T a b c = MkT (Foo a b c) deriving( Eq )
	instance (C Int a, Eq b, Eq c) => Eq (Foo a b c)

Notice that this instance (just) satisfies the Paterson termination 
conditions.  Then we *could* derive an instance decl like this:

	instance (C Int a, Eq b, Eq c) => Eq (T a b c) 
even though there is no instance for (C Int a), because there just
*might* be an instance for, say, (C Int Bool) at a site where we
need the equality instance for T's.  

However, this seems pretty exotic, and it's quite tricky to allow
this, and yet give sensible error messages in the (much more common)
case where we really want that instance decl for C.

So for now we simply require that the derived instance context
should have only type-variable constraints.

Here is another example:
	data Fix f = In (f (Fix f)) deriving( Eq )
Here, if we are prepared to allow -XUndecidableInstances we
could derive the instance
	instance Eq (f (Fix f)) => Eq (Fix f)
but this is so delicate that I don't think it should happen inside
'deriving'. If you want this, write it yourself!

NB: if you want to lift this condition, make sure you still meet the
termination conditions!  If not, the deriving mechanism generates
larger and larger constraints.  Example:
  data Succ a = S a
  data Seq a = Cons a (Seq (Succ a)) | Nil deriving Show

Note the lack of a Show instance for Succ.  First we'll generate
  instance (Show (Succ a), Show a) => Show (Seq a)
and then
  instance (Show (Succ (Succ a)), Show (Succ a), Show a) => Show (Seq a)
and so on.  Instead we want to complain of no instance for (Show (Succ a)).

The bottom line
~~~~~~~~~~~~~~~
Allow constraints which consist only of type variables, with no repeats.

*********************************************************************************
*                                                                                 * 
*                            Inference
*                                                                                 *
***********************************************************************************

Note [Which variables to quantify]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Suppose the inferred type of a function is
   T kappa (alpha:kappa) -> Int
where alpha is a type unification variable and 
      kappa is a kind unification variable
Then we want to quantify over *both* alpha and kappa.  But notice that
kappa appears "at top level" of the type, as well as inside the kind
of alpha.  So it should be fine to just look for the "top level"
kind/type variables of the type, without looking transitively into the
kinds of those type variables.

\begin{code}
<pre><a name="line-1"></a><a name="simplifyInfer"></a><span class='hs-definition'>simplifyInfer</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-2"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>                  <span class='hs-comment'>-- Apply monomorphism restriction</span>
<a name="line-3"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Name</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTauType</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- Variables to be generalised,</span>
<a name="line-4"></a>                                       <span class='hs-comment'>-- and their tau-types</span>
<a name="line-5"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Untouchables</span><span class='hs-layout'>,</span> <span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>)</span>
<a name="line-6"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>    <span class='hs-comment'>-- Quantify over these type variables</span>
<a name="line-7"></a>                      <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- ... and these constraints</span>
<a name="line-8"></a>		      <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>	    <span class='hs-comment'>-- The monomorphism restriction did something</span>
<a name="line-9"></a>		      		    <span class='hs-comment'>--   so the results type is not as general as</span>
<a name="line-10"></a>				    <span class='hs-comment'>--   it could be</span>
<a name="line-11"></a>                      <span class='hs-conid'>TcEvBinds</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- ... binding these evidence variables</span>
<a name="line-12"></a><span class='hs-definition'>simplifyInfer</span> <span class='hs-sel'>_top_lvl</span> <span class='hs-varid'>apply_mr</span> <span class='hs-varid'>name_taus</span> <span class='hs-layout'>(</span><span class='hs-varid'>untch</span><span class='hs-layout'>,</span><span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-13"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wanteds</span>
<a name="line-14"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>gbl_tvs</span>     <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetGlobalTyVars</span>            <span class='hs-comment'>-- Already zonked</span>
<a name="line-15"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_taus</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>snd</span> <span class='hs-varid'>name_taus</span><span class='hs-layout'>)</span>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>tvs_to_quantify</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>varSetElems</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>zonked_taus</span> <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>gbl_tvs</span><span class='hs-layout'>)</span>
<a name="line-17"></a>       	     		       <span class='hs-comment'>-- tvs_to_quantify can contain both kind and type vars</span>
<a name="line-18"></a>       	                       <span class='hs-comment'>-- See Note [Which variables to quantify]</span>
<a name="line-19"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>qtvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkQuantifiedTyVars</span> <span class='hs-varid'>tvs_to_quantify</span>
<a name="line-20"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyTcEvBinds</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-21"></a>
<a name="line-22"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-23"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>runtimeCoercionErrors</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>doptM</span> <span class='hs-conid'>Opt_DeferTypeErrors</span>
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>gbl_tvs</span>        <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetGlobalTyVars</span>
<a name="line-25"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_tau_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTyVarsAndFV</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>snd</span> <span class='hs-varid'>name_taus</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-26"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_wanteds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkWC</span> <span class='hs-varid'>wanteds</span>
<a name="line-27"></a>
<a name="line-28"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInfer {"</span>  <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-29"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"names ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>name_taus</span><span class='hs-layout'>)</span>
<a name="line-30"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"taus ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>snd</span> <span class='hs-varid'>name_taus</span><span class='hs-layout'>)</span>
<a name="line-31"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"tau_tvs (zonked) ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_tau_tvs</span>
<a name="line-32"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"gbl_tvs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>gbl_tvs</span>
<a name="line-33"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"closed ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-sel'>_top_lvl</span>
<a name="line-34"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"apply_mr ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>apply_mr</span>
<a name="line-35"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"untch ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>untch</span>
<a name="line-36"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"wanted ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_wanteds</span>
<a name="line-37"></a>             <span class='hs-keyglyph'>]</span>
<a name="line-38"></a>
<a name="line-39"></a>              <span class='hs-comment'>-- Historical note: Before step 2 we used to have a</span>
<a name="line-40"></a>              <span class='hs-comment'>-- HORRIBLE HACK described in Note [Avoid unecessary</span>
<a name="line-41"></a>              <span class='hs-comment'>-- constraint simplification] but, as described in Trac</span>
<a name="line-42"></a>              <span class='hs-comment'>-- #4361, we have taken in out now.  That's why we start</span>
<a name="line-43"></a>              <span class='hs-comment'>-- with step 2!</span>
<a name="line-44"></a>
<a name="line-45"></a>              <span class='hs-comment'>-- Step 2) First try full-blown solving </span>
<a name="line-46"></a>
<a name="line-47"></a>              <span class='hs-comment'>-- NB: we must gather up all the bindings from doing</span>
<a name="line-48"></a>              <span class='hs-comment'>-- this solving; hence (runTcSWithEvBinds ev_binds_var).</span>
<a name="line-49"></a>              <span class='hs-comment'>-- And note that since there are nested implications,</span>
<a name="line-50"></a>              <span class='hs-comment'>-- calling solveWanteds will side-effect their evidence</span>
<a name="line-51"></a>              <span class='hs-comment'>-- bindings, so we can't just revert to the input</span>
<a name="line-52"></a>              <span class='hs-comment'>-- constraint.</span>
<a name="line-53"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newTcEvBinds</span>
<a name="line-54"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanted_transformed</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>zonked_wanteds</span>
<a name="line-55"></a>
<a name="line-56"></a>              <span class='hs-comment'>-- Step 3) Fail fast if there is an insoluble constraint,</span>
<a name="line-57"></a>              <span class='hs-comment'>-- unless we are deferring errors to runtime</span>
<a name="line-58"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>runtimeCoercionErrors</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>wanted_transformed</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> 
<a name="line-59"></a>         <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-sel'>_ev_binds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>reportUnsolved</span> <span class='hs-conid'>False</span> <span class='hs-varid'>wanted_transformed</span><span class='hs-layout'>;</span> <span class='hs-varid'>failM</span> <span class='hs-layout'>}</span>
<a name="line-60"></a>
<a name="line-61"></a>              <span class='hs-comment'>-- Step 4) Candidates for quantification are an approximation of wanted_transformed</span>
<a name="line-62"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>quant_candidates</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>approximateWC</span> <span class='hs-varid'>wanted_transformed</span>               
<a name="line-63"></a>              <span class='hs-comment'>-- NB: Already the fixpoint of any unifications that may have happened                                </span>
<a name="line-64"></a>              <span class='hs-comment'>-- NB: We do not do any defaulting when inferring a type, this can lead</span>
<a name="line-65"></a>              <span class='hs-comment'>-- to less polymorphic types, see Note [Default while Inferring]</span>
<a name="line-66"></a>              <span class='hs-comment'>-- NB: quant_candidates here are wanted or derived, we filter the wanteds later, anyway</span>
<a name="line-67"></a> 
<a name="line-68"></a>              <span class='hs-comment'>-- Step 5) Minimize the quantification candidates                             </span>
<a name="line-69"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>quant_candidates_transformed</span><span class='hs-layout'>,</span> <span class='hs-sel'>_extra_binds</span><span class='hs-layout'>)</span>   
<a name="line-70"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWanteds</span> <span class='hs-varop'>$</span> <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>quant_candidates</span>
<a name="line-71"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyBag</span>
<a name="line-72"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyBag</span> <span class='hs-layout'>}</span>
<a name="line-73"></a>
<a name="line-74"></a>              <span class='hs-comment'>-- Step 6) Final candidates for quantification                </span>
<a name="line-75"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>final_quant_candidates</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span>
<a name="line-76"></a>             <span class='hs-varid'>final_quant_candidates</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>ctPred</span> <span class='hs-varop'>$</span> <span class='hs-varid'>bagToList</span> <span class='hs-varop'>$</span>
<a name="line-77"></a>                                      <span class='hs-varid'>keepWanted</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_flat</span> <span class='hs-varid'>quant_candidates_transformed</span><span class='hs-layout'>)</span>
<a name="line-78"></a>             <span class='hs-comment'>-- NB: Already the fixpoint of any unifications that may have happened</span>
<a name="line-79"></a>             <span class='hs-comment'>-- But need to zonk out the flatten-skolems</span>
<a name="line-80"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>final_quant_candidates</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-varid'>final_quant_candidates</span>
<a name="line-81"></a>                  
<a name="line-82"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>gbl_tvs</span>        <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetGlobalTyVars</span> <span class='hs-comment'>-- TODO: can we just use untch instead of gbl_tvs?</span>
<a name="line-83"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_tau_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTyVarsAndFV</span> <span class='hs-varid'>zonked_tau_tvs</span>
<a name="line-84"></a>       
<a name="line-85"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyWithApprox"</span> <span class='hs-varop'>$</span>
<a name="line-86"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"final_quant_candidates ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>final_quant_candidates</span>
<a name="line-87"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"gbl_tvs="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>gbl_tvs</span>
<a name="line-88"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"zonked_tau_tvs="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_tau_tvs</span> <span class='hs-keyglyph'>]</span>
<a name="line-89"></a>         
<a name="line-90"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>init_tvs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zonked_tau_tvs</span> <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>gbl_tvs</span>
<a name="line-91"></a>             <span class='hs-varid'>poly_qtvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>growThetaTyVars</span> <span class='hs-varid'>final_quant_candidates</span> <span class='hs-varid'>init_tvs</span> 
<a name="line-92"></a>                         <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>gbl_tvs</span>
<a name="line-93"></a>             <span class='hs-varid'>pbound</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>quantifyPred</span> <span class='hs-varid'>poly_qtvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>final_quant_candidates</span>
<a name="line-94"></a>             
<a name="line-95"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyWithApprox"</span> <span class='hs-varop'>$</span>
<a name="line-96"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"pbound ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>pbound</span>
<a name="line-97"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"init_qtvs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>init_tvs</span> 
<a name="line-98"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"poly_qtvs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>poly_qtvs</span> <span class='hs-keyglyph'>]</span>
<a name="line-99"></a>         
<a name="line-100"></a>	     <span class='hs-comment'>-- Monomorphism restriction</span>
<a name="line-101"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>mr_qtvs</span>  	     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>init_tvs</span> <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>constrained_tvs</span>
<a name="line-102"></a>             <span class='hs-varid'>constrained_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>final_quant_candidates</span>
<a name="line-103"></a>	     <span class='hs-varid'>mr_bites</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>apply_mr</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>pbound</span><span class='hs-layout'>)</span>
<a name="line-104"></a>
<a name="line-105"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>bound</span><span class='hs-layout'>)</span>
<a name="line-106"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>mr_bites</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mr_qtvs</span><span class='hs-layout'>,</span>   <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-107"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_qtvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>pbound</span><span class='hs-layout'>)</span>
<a name="line-108"></a>             
<a name="line-109"></a>
<a name="line-110"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isEmptyVarSet</span> <span class='hs-varid'>qtvs</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>null</span> <span class='hs-varid'>bound</span>
<a name="line-111"></a>         <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"} simplifyInfer/no quantification"</span> <span class='hs-varid'>empty</span>                   
<a name="line-112"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>emitConstraints</span> <span class='hs-varid'>wanted_transformed</span>
<a name="line-113"></a>                    <span class='hs-comment'>-- Includes insolubles (if -fdefer-type-errors)</span>
<a name="line-114"></a>                    <span class='hs-comment'>-- as well as flats and implications</span>
<a name="line-115"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>mr_bites</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcEvBinds</span> <span class='hs-varid'>ev_binds_var</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-116"></a>         <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span>
<a name="line-117"></a>
<a name="line-118"></a>       <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyApprox"</span> <span class='hs-varop'>$</span> 
<a name="line-119"></a>         <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"bound are ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bound</span> 
<a name="line-120"></a>         
<a name="line-121"></a>            <span class='hs-comment'>-- Step 4, zonk quantified variables </span>
<a name="line-122"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>minimal_flat_preds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkMinimalBySCs</span> <span class='hs-varid'>bound</span>
<a name="line-123"></a>             <span class='hs-varid'>skol_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InferSkol</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkSigmaTy</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>minimal_flat_preds</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-124"></a>                                   <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>name_taus</span> <span class='hs-keyglyph'>]</span>
<a name="line-125"></a>                        <span class='hs-comment'>-- Don't add the quantified variables here, because</span>
<a name="line-126"></a>                        <span class='hs-comment'>-- they are also bound in ic_skols and we want them to be</span>
<a name="line-127"></a>                        <span class='hs-comment'>-- tidied uniformly</span>
<a name="line-128"></a>
<a name="line-129"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>qtvs_to_return</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkQuantifiedTyVars</span> <span class='hs-layout'>(</span><span class='hs-varid'>varSetElems</span> <span class='hs-varid'>qtvs</span><span class='hs-layout'>)</span>
<a name="line-130"></a>
<a name="line-131"></a>            <span class='hs-comment'>-- Step 7) Emit an implication</span>
<a name="line-132"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>minimal_bound_ev_vars</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-conid'>TcMType</span><span class='hs-varop'>.</span><span class='hs-varid'>newEvVar</span> <span class='hs-varid'>minimal_flat_preds</span>
<a name="line-133"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>lcl_env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getLclTypeEnv</span>
<a name="line-134"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>gloc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getCtLoc</span> <span class='hs-varid'>skol_info</span>
<a name="line-135"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>implic</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_untch</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>untch</span> 
<a name="line-136"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_env</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lcl_env</span>
<a name="line-137"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_skols</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>qtvs_to_return</span>
<a name="line-138"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_given</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>minimal_bound_ev_vars</span>
<a name="line-139"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wanted_transformed</span> 
<a name="line-140"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_insol</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-141"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_binds</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-142"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_loc</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gloc</span> <span class='hs-layout'>}</span>
<a name="line-143"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>emitImplication</span> <span class='hs-varid'>implic</span>
<a name="line-144"></a>         
<a name="line-145"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"} simplifyInfer/produced residual implication for quantification"</span> <span class='hs-varop'>$</span>
<a name="line-146"></a>             <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"implic ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>implic</span>
<a name="line-147"></a>                       <span class='hs-comment'>-- ic_skols, ic_given give rest of result</span>
<a name="line-148"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"qtvs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>qtvs_to_return</span>
<a name="line-149"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"spb ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>final_quant_candidates</span>
<a name="line-150"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"bound ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bound</span> <span class='hs-keyglyph'>]</span>
<a name="line-151"></a>
<a name="line-152"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>qtvs_to_return</span><span class='hs-layout'>,</span> <span class='hs-varid'>minimal_bound_ev_vars</span>
<a name="line-153"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>mr_bites</span><span class='hs-layout'>,</span>  <span class='hs-conid'>TcEvBinds</span> <span class='hs-varid'>ev_binds_var</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-154"></a>    <span class='hs-keyword'>where</span> 
</pre>\end{code}


Note [Default while Inferring]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Our current plan is that defaulting only happens at simplifyTop and
not simplifyInfer.  This may lead to some insoluble deferred constraints
Example:

instance D g => C g Int b 

constraint inferred = (forall b. 0 => C gamma alpha b) /\ Num alpha
type inferred       = gamma -> gamma 

Now, if we try to default (alpha := Int) we will be able to refine the implication to 
  (forall b. 0 => C gamma Int b) 
which can then be simplified further to 
  (forall b. 0 => D gamma)
Finally we /can/ approximate this implication with (D gamma) and infer the quantified
type:  forall g. D g => g -> g

Instead what will currently happen is that we will get a quantified type 
(forall g. g -> g) and an implication:
       forall g. 0 => (forall b. 0 => C g alpha b) /\ Num alpha

which, even if the simplifyTop defaults (alpha := Int) we will still be left with an 
unsolvable implication:
       forall g. 0 => (forall b. 0 => D g)

The concrete example would be: 
       h :: C g a s => g -> a -> ST s a
       f (x::gamma) = (\_ -> x) (runST (h x (undefined::alpha)) + 1)

But it is quite tedious to do defaulting and resolve the implication constraints and
we have not observed code breaking because of the lack of defaulting in inference so 
we don't do it for now.



Note [Minimize by Superclasses]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

When we quantify over a constraint, in simplifyInfer we need to
quantify over a constraint that is minimal in some sense: For
instance, if the final wanted constraint is (Eq alpha, Ord alpha),
we'd like to quantify over Ord alpha, because we can just get Eq alpha
from superclass selection from Ord alpha. This minimization is what
mkMinimalBySCs does. Then, simplifyInfer uses the minimal constraint
to check the original wanted.

\begin{code}
<pre><a name="line-1"></a><a name="approximateWC"></a><span class='hs-definition'>approximateWC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>
<a name="line-2"></a><span class='hs-comment'>-- Postcondition: Wanted or Derived Cts </span>
<a name="line-3"></a><span class='hs-definition'>approximateWC</span> <span class='hs-varid'>wc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>float_wc</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>wc</span>
<a name="line-4"></a>  <span class='hs-keyword'>where</span> 
<a name="line-5"></a>    <span class='hs-varid'>float_wc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>
<a name="line-6"></a>    <span class='hs-varid'>float_wc</span> <span class='hs-varid'>skols</span> <span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flat</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implic</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>floats1</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>floats2</span>
<a name="line-7"></a>      <span class='hs-keyword'>where</span> <span class='hs-varid'>floats1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>do_bag</span> <span class='hs-layout'>(</span><span class='hs-varid'>float_flat</span> <span class='hs-varid'>skols</span><span class='hs-layout'>)</span> <span class='hs-varid'>flat</span>
<a name="line-8"></a>            <span class='hs-varid'>floats2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>do_bag</span> <span class='hs-layout'>(</span><span class='hs-varid'>float_implic</span> <span class='hs-varid'>skols</span><span class='hs-layout'>)</span> <span class='hs-varid'>implic</span>
<a name="line-9"></a>                                 
<a name="line-10"></a>    <span class='hs-varid'>float_implic</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Implication</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>
<a name="line-11"></a>    <span class='hs-varid'>float_implic</span> <span class='hs-varid'>skols</span> <span class='hs-varid'>imp</span>
<a name="line-12"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>float_wc</span> <span class='hs-layout'>(</span><span class='hs-varid'>skols</span> <span class='hs-varop'>`extendVarSetList`</span> <span class='hs-varid'>ic_skols</span> <span class='hs-varid'>imp</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ic_wanted</span> <span class='hs-varid'>imp</span><span class='hs-layout'>)</span>
<a name="line-13"></a>            
<a name="line-14"></a>    <span class='hs-varid'>float_flat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>
<a name="line-15"></a>    <span class='hs-varid'>float_flat</span> <span class='hs-varid'>skols</span> <span class='hs-varid'>ct</span>
<a name="line-16"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tyVarsOfCt</span> <span class='hs-varid'>ct</span> <span class='hs-varop'>`disjointVarSet`</span> <span class='hs-varid'>skols</span> 
<a name="line-17"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>singleCt</span> <span class='hs-varid'>ct</span>
<a name="line-18"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyCts</span>
<a name="line-19"></a>        
<a name="line-20"></a>    <span class='hs-varid'>do_bag</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>c</span>
<a name="line-21"></a>    <span class='hs-varid'>do_bag</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>unionBags</span><span class='hs-varop'>.</span><span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyBag</span>
</pre>\end{code}

Note [Avoid unecessary constraint simplification]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    -------- NB NB NB (Jun 12) ------------- 
    This note not longer applies; see the notes with Trac #4361.
    But I'm leaving it in here so we remember the issue.)
    ----------------------------------------
When inferring the type of a let-binding, with simplifyInfer,
try to avoid unnecessarily simplifying class constraints.
Doing so aids sharing, but it also helps with delicate 
situations like

   instance C t => C [t] where ..

   f :: C [t] => ....
   f x = let g y = ...(constraint C [t])... 
         in ...
When inferring a type for 'g', we don't want to apply the
instance decl, because then we can't satisfy (C t).  So we
just notice that g isn't quantified over 't' and partition
the contraints before simplifying.

This only half-works, but then let-generalisation only half-works.


*********************************************************************************
*                                                                                 * 
*                             RULES                                               *
*                                                                                 *
***********************************************************************************

See note [Simplifying RULE consraints] in TcRule

Note [RULE quanfification over equalities]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Decideing which equalities to quantify over is tricky:
 * We do not want to quantify over insoluble equalities (Int ~ Bool)
    (a) because we prefer to report a LHS type error
    (b) because if such things end up in 'givens' we get a bogus
        "inaccessible code" error

 * But we do want to quantify over things like (a ~ F b), where
   F is a type function.

The difficulty is that it's hard to tell what is insoluble!
So we see whether the simplificaiotn step yielded any type errors,
and if so refrain from quantifying over *any* equalites.

\begin{code}
<pre><a name="line-1"></a><a name="simplifyRule"></a><span class='hs-definition'>simplifyRule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleName</span> 
<a name="line-2"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>	<span class='hs-comment'>-- Constraints from LHS</span>
<a name="line-3"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>	<span class='hs-comment'>-- Constraints from RHS</span>
<a name="line-4"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- LHS evidence varaibles</span>
<a name="line-5"></a><span class='hs-comment'>-- See Note [Simplifying RULE constraints] in TcRule</span>
<a name="line-6"></a><span class='hs-definition'>simplifyRule</span> <span class='hs-varid'>name</span> <span class='hs-varid'>lhs_wanted</span> <span class='hs-varid'>rhs_wanted</span>
<a name="line-7"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>zonked_all</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkWC</span> <span class='hs-layout'>(</span><span class='hs-varid'>lhs_wanted</span> <span class='hs-varop'>`andWC`</span> <span class='hs-varid'>rhs_wanted</span><span class='hs-layout'>)</span>
<a name="line-8"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>doc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"LHS of rule"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>doubleQuotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ftext</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span>
<a name="line-9"></a>             
<a name="line-10"></a>             	 <span class='hs-comment'>-- We allow ourselves to unify environment </span>
<a name="line-11"></a>		 <span class='hs-comment'>-- variables: runTcS runs with NoUntouchables</span>
<a name="line-12"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>resid_wanted</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWanteds</span> <span class='hs-varid'>zonked_all</span>
<a name="line-13"></a>
<a name="line-14"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_lhs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkWC</span> <span class='hs-varid'>lhs_wanted</span>
<a name="line-15"></a>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>q_cts</span><span class='hs-layout'>,</span> <span class='hs-varid'>non_q_cts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span> <span class='hs-varid'>quantify_me</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_flat</span> <span class='hs-varid'>zonked_lhs</span><span class='hs-layout'>)</span>
<a name="line-17"></a>             <span class='hs-varid'>quantify_me</span>  <span class='hs-comment'>-- Note [RULE quantification over equalities]</span>
<a name="line-18"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>resid_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>quantify_insol</span>
<a name="line-19"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>quantify_normal</span>
<a name="line-20"></a>
<a name="line-21"></a>             <span class='hs-varid'>quantify_insol</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEqPred</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-22"></a>
<a name="line-23"></a>             <span class='hs-varid'>quantify_normal</span> <span class='hs-varid'>ct</span>
<a name="line-24"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EqPred</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-25"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>t1</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>
<a name="line-26"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-27"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-28"></a>             
<a name="line-29"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyRule"</span> <span class='hs-varop'>$</span>
<a name="line-30"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>doc</span>
<a name="line-31"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"zonked_lhs"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_lhs</span> 
<a name="line-32"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"q_cts"</span>      <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>q_cts</span> <span class='hs-keyglyph'>]</span>
<a name="line-33"></a>
<a name="line-34"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvId</span> <span class='hs-varop'>.</span> <span class='hs-varid'>ctEvidence</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>bagToList</span> <span class='hs-varid'>q_cts</span><span class='hs-layout'>)</span>
<a name="line-35"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>zonked_lhs</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>non_q_cts</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}


*********************************************************************************
*                                                                                 * 
*                                 Main Simplifier                                 *
*                                                                                 *
***********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="simplifyCheck"></a><span class='hs-definition'>simplifyCheck</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span>	<span class='hs-comment'>-- Wanted</span>
<a name="line-2"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-3"></a><span class='hs-comment'>-- Solve a single, top-level implication constraint</span>
<a name="line-4"></a><span class='hs-comment'>-- e.g. typically one created from a top-level type signature</span>
<a name="line-5"></a><span class='hs-comment'>-- 	    f :: forall a. [a] -&gt; [a]</span>
<a name="line-6"></a><span class='hs-comment'>--          f x = rhs</span>
<a name="line-7"></a><span class='hs-comment'>-- We do this even if the function has no polymorphism:</span>
<a name="line-8"></a><span class='hs-comment'>--    	    g :: Int -&gt; Int</span>
<a name="line-9"></a>
<a name="line-10"></a><span class='hs-comment'>--          g y = rhs</span>
<a name="line-11"></a><span class='hs-comment'>-- (whereas for *nested* bindings we would not create</span>
<a name="line-12"></a><span class='hs-comment'>--  an implication constraint for g at all.)</span>
<a name="line-13"></a><span class='hs-comment'>--</span>
<a name="line-14"></a><span class='hs-comment'>-- Fails if can't solve something in the input wanteds</span>
<a name="line-15"></a><span class='hs-definition'>simplifyCheck</span> <span class='hs-varid'>wanteds</span>
<a name="line-16"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wanteds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkWC</span> <span class='hs-varid'>wanteds</span>
<a name="line-17"></a>
<a name="line-18"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyCheck {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span>
<a name="line-19"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"wanted ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-20"></a>
<a name="line-21"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>unsolved</span><span class='hs-layout'>,</span> <span class='hs-varid'>eb1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWanteds</span> <span class='hs-varid'>wanteds</span>
<a name="line-22"></a>
<a name="line-23"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyCheck }"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"unsolved ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved</span>
<a name="line-24"></a>
<a name="line-25"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved {"</span> <span class='hs-varid'>empty</span>
<a name="line-26"></a>       <span class='hs-comment'>-- See Note [Deferring coercion errors to runtime]</span>
<a name="line-27"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>runtimeCoercionErrors</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>doptM</span> <span class='hs-conid'>Opt_DeferTypeErrors</span>
<a name="line-28"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>eb2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>reportUnsolved</span> <span class='hs-varid'>runtimeCoercionErrors</span> <span class='hs-varid'>unsolved</span> 
<a name="line-29"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved }"</span> <span class='hs-varid'>empty</span>
<a name="line-30"></a>
<a name="line-31"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>eb1</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>eb2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}

Note [Deferring coercion errors to runtime]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

While developing, sometimes it is desirable to allow compilation to succeed even
if there are type errors in the code. Consider the following case:

  module Main where

  a :: Int
  a = 'a'

  main = print "b"

Even though `a` is ill-typed, it is not used in the end, so if all that we're
interested in is `main` it is handy to be able to ignore the problems in `a`.

Since we treat type equalities as evidence, this is relatively simple. Whenever
we run into a type mismatch in TcUnify, we normally just emit an error. But it
is always safe to defer the mismatch to the main constraint solver. If we do
that, `a` will get transformed into

  co :: Int ~ Char
  co = ...

  a :: Int
  a = 'a' `cast` co

The constraint solver would realize that `co` is an insoluble constraint, and
emit an error with `reportUnsolved`. But we can also replace the right-hand side
of `co` with `error "Deferred type error: Int ~ Char"`. This allows the program
to compile, and it will run fine unless we evaluate `a`. This is what
`deferErrorsToRuntime` does.

It does this by keeping track of which errors correspond to which coercion
in TcErrors (with ErrEnv). TcErrors.reportTidyWanteds does not print the errors
and does not fail if -fwarn-type-errors is on, so that we can continue
compilation. The errors are turned into warnings in `reportUnsolved`.

\begin{code}
<pre><a name="line-1"></a>
<a name="line-2"></a><a name="solveWanteds"></a><span class='hs-definition'>solveWanteds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-3"></a><span class='hs-comment'>-- Return the evidence binds in the BagEvBinds result</span>
<a name="line-4"></a><span class='hs-definition'>solveWanteds</span> <span class='hs-varid'>wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>solve_wanteds</span> <span class='hs-varid'>wanted</span> 
<a name="line-5"></a>
<a name="line-6"></a><a name="solveWantedsWithEvBinds"></a><span class='hs-definition'>solveWantedsWithEvBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>EvBindsVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-7"></a><span class='hs-comment'>-- Side-effect the EvBindsVar argument to add new bindings from solving</span>
<a name="line-8"></a><span class='hs-definition'>solveWantedsWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wanted</span>
<a name="line-9"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runTcSWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varop'>$</span> <span class='hs-varid'>solve_wanteds</span> <span class='hs-varid'>wanted</span>
<a name="line-10"></a>
<a name="line-11"></a>
<a name="line-12"></a><a name="solve_wanteds"></a><span class='hs-definition'>solve_wanteds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span> 
<a name="line-13"></a><span class='hs-comment'>-- NB: wc_flats may be wanted /or/ derived now</span>
<a name="line-14"></a><span class='hs-definition'>solve_wanteds</span> <span class='hs-varid'>wanted</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flats</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insols</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> 
<a name="line-15"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-16"></a>
<a name="line-17"></a>         <span class='hs-comment'>-- Try the flat bit, including insolubles. Solving insolubles a </span>
<a name="line-18"></a>         <span class='hs-comment'>-- second time round is a bit of a waste but the code is simple </span>
<a name="line-19"></a>         <span class='hs-comment'>-- and the program is wrong anyway, and we don't run the danger </span>
<a name="line-20"></a>         <span class='hs-comment'>-- of adding Derived insolubles twice; see </span>
<a name="line-21"></a>         <span class='hs-comment'>-- TcSMonad Note [Do not add duplicate derived insolubles] </span>
<a name="line-22"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>all_flats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flats</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>insols</span>
<a name="line-23"></a>                         
<a name="line-24"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>impls_from_flats</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveInteractCts</span> <span class='hs-varop'>$</span> <span class='hs-varid'>bagToList</span> <span class='hs-varid'>all_flats</span>
<a name="line-25"></a>
<a name="line-26"></a>       <span class='hs-comment'>-- solve_wanteds iterates when it is able to float equalities </span>
<a name="line-27"></a>       <span class='hs-comment'>-- out of one or more of the implications. </span>
<a name="line-28"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simpl_loop</span> <span class='hs-num'>1</span> <span class='hs-layout'>(</span><span class='hs-varid'>implics</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>impls_from_flats</span><span class='hs-layout'>)</span>
<a name="line-29"></a>
<a name="line-30"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>is</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span> 
<a name="line-31"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>insoluble_flats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getInertInsols</span> <span class='hs-varid'>is</span>
<a name="line-32"></a>             <span class='hs-varid'>unsolved_flats</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getInertUnsolved</span> <span class='hs-varid'>is</span>
<a name="line-33"></a>
<a name="line-34"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>bb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcEvBindsMap</span>
<a name="line-35"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSTyBindsMap</span>
<a name="line-36"></a>
<a name="line-37"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds }"</span> <span class='hs-varop'>$</span>
<a name="line-38"></a>                 <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_flats   ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-39"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_implics ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_implics</span>
<a name="line-40"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"current evbinds  ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>evBindMapBinds</span> <span class='hs-varid'>bb</span><span class='hs-layout'>)</span>
<a name="line-41"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"current tybinds  ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>vcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>varEnvElts</span> <span class='hs-varid'>tb</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-42"></a>                      <span class='hs-keyglyph'>]</span>
<a name="line-43"></a>
<a name="line-44"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>wc</span> <span class='hs-keyglyph'>=</span>  <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-45"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsolved_implics</span>
<a name="line-46"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insoluble_flats</span> <span class='hs-layout'>}</span>
<a name="line-47"></a>
<a name="line-48"></a>
<a name="line-49"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds finished with"</span> <span class='hs-varop'>$</span>
<a name="line-50"></a>                 <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"wc (unflattened) ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wc</span> <span class='hs-keyglyph'>]</span>
<a name="line-51"></a>
<a name="line-52"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unFlattenWC</span> <span class='hs-varid'>wc</span> <span class='hs-layout'>}</span>
<a name="line-53"></a>
<a name="line-54"></a>
<a name="line-55"></a>
<a name="line-56"></a><a name="simpl_loop"></a><span class='hs-definition'>simpl_loop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<a name="line-57"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span>
<a name="line-58"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span>
<a name="line-59"></a><span class='hs-definition'>simpl_loop</span> <span class='hs-varid'>n</span> <span class='hs-varid'>implics</span>
<a name="line-60"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>10</span> 
<a name="line-61"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds: loop!"</span> <span class='hs-varid'>empty</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>implics</span>
<a name="line-62"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> 
<a name="line-63"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>implic_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_implics</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveNestedImplications</span> <span class='hs-varid'>implics</span>
<a name="line-64"></a>
<a name="line-65"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>improve_eqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implic_eqs</span>
<a name="line-66"></a>             <span class='hs-comment'>-- NB: improve_eqs used to contain defaulting equations HERE but </span>
<a name="line-67"></a>             <span class='hs-comment'>-- defaulting now happens only at simplifyTop and not deep inside </span>
<a name="line-68"></a>             <span class='hs-comment'>-- simpl_loop! See Note [Top-level Defaulting Plan]</span>
<a name="line-69"></a>
<a name="line-70"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unsolved_flats</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-varop'>.</span> <span class='hs-varid'>getInertUnsolved</span><span class='hs-layout'>)</span> 
<a name="line-71"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds: simpl_loop end"</span> <span class='hs-varop'>$</span>
<a name="line-72"></a>             <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"improve_eqs      ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>improve_eqs</span>
<a name="line-73"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_flats   ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-74"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_implics ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-keyglyph'>]</span>
<a name="line-75"></a>
<a name="line-76"></a>
<a name="line-77"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>improve_eqs</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>unsolved_implics</span> 
<a name="line-78"></a>         <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>impls_from_eqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveInteractCts</span> <span class='hs-varop'>$</span> <span class='hs-varid'>bagToList</span> <span class='hs-varid'>improve_eqs</span>
<a name="line-79"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>simpl_loop</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>unsolved_implics</span> <span class='hs-varop'>`unionBags`</span> 
<a name="line-80"></a>                                                 <span class='hs-varid'>impls_from_eqs</span><span class='hs-layout'>)</span><span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-81"></a>
<a name="line-82"></a>
<a name="line-83"></a><a name="solveNestedImplications"></a><span class='hs-definition'>solveNestedImplications</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span>
<a name="line-84"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span>
<a name="line-85"></a><span class='hs-comment'>-- Precondition: the TcS inerts may contain unsolved flats which have </span>
<a name="line-86"></a><span class='hs-comment'>-- to be converted to givens before we go inside a nested implication.</span>
<a name="line-87"></a><span class='hs-definition'>solveNestedImplications</span> <span class='hs-varid'>implics</span>
<a name="line-88"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>implics</span>
<a name="line-89"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyBag</span><span class='hs-layout'>)</span>
<a name="line-90"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> 
<a name="line-91"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inerts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span>
<a name="line-92"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveNestedImplications starting, inerts are:"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inerts</span>         
<a name="line-93"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>pushed_givens</span><span class='hs-layout'>,</span> <span class='hs-varid'>thinner_inerts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitInertsForImplications</span> <span class='hs-varid'>inerts</span>
<a name="line-94"></a>  
<a name="line-95"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveNestedImplications starting, more info:"</span> <span class='hs-varop'>$</span> 
<a name="line-96"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"original inerts = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inerts</span>
<a name="line-97"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"pushed_givens   = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>pushed_givens</span>
<a name="line-98"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"thinner_inerts  = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>thinner_inerts</span> <span class='hs-keyglyph'>]</span>
<a name="line-99"></a>         
<a name="line-100"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>implic_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_implics</span><span class='hs-layout'>)</span>
<a name="line-101"></a>           <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>doWithInert</span> <span class='hs-varid'>thinner_inerts</span> <span class='hs-varop'>$</span> 
<a name="line-102"></a>              <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>tcs_untouchables</span> 
<a name="line-103"></a>                         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>unionVarSet</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tyVarsOfCt</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>pushed_givens</span>
<a name="line-104"></a>                                          <span class='hs-comment'>-- Typically pushed_givens is very small, consists</span>
<a name="line-105"></a>                                          <span class='hs-comment'>-- only of unsolved equalities, so no inefficiency </span>
<a name="line-106"></a>                                          <span class='hs-comment'>-- danger.</span>
<a name="line-107"></a>                                                                                    
<a name="line-108"></a>                                          
<a name="line-109"></a>                 <span class='hs-comment'>-- See Note [Preparing inert set for implications]</span>
<a name="line-110"></a>	         <span class='hs-comment'>-- Push the unsolved wanteds inwards, but as givens</span>
<a name="line-111"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds: preparing inerts for implications {"</span> <span class='hs-varop'>$</span> 
<a name="line-112"></a>                   <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tcs_untouchables</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>pushed_givens</span><span class='hs-keyglyph'>]</span>
<a name="line-113"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>impls_from_givens</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveInteractCts</span> <span class='hs-varid'>pushed_givens</span>
<a name="line-114"></a>                                        
<a name="line-115"></a>                 <span class='hs-layout'>;</span> <span class='hs-conid'>MASSERT</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>impls_from_givens</span><span class='hs-layout'>)</span>
<a name="line-116"></a>                       <span class='hs-comment'>-- impls_from_givens must be empty, since we are reacting givens</span>
<a name="line-117"></a>                       <span class='hs-comment'>-- with givens, and they can never generate extra implications </span>
<a name="line-118"></a>                       <span class='hs-comment'>-- from decomposition of ForAll types. (Whereas wanteds can, see</span>
<a name="line-119"></a>                       <span class='hs-comment'>-- TcCanonical, canEq ForAll-ForAll case)</span>
<a name="line-120"></a>                   
<a name="line-121"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds: } now doing nested implications {"</span> <span class='hs-varid'>empty</span>
<a name="line-122"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>flatMapBagPairM</span> <span class='hs-layout'>(</span><span class='hs-varid'>solveImplication</span> <span class='hs-varid'>tcs_untouchables</span><span class='hs-layout'>)</span> <span class='hs-varid'>implics</span> <span class='hs-layout'>}</span>
<a name="line-123"></a>
<a name="line-124"></a>       <span class='hs-comment'>-- ... and we are back in the original TcS inerts </span>
<a name="line-125"></a>       <span class='hs-comment'>-- Notice that the original includes the _insoluble_flats so it was safe to ignore</span>
<a name="line-126"></a>       <span class='hs-comment'>-- them in the beginning of this function.</span>
<a name="line-127"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds: done nested implications }"</span> <span class='hs-varop'>$</span>
<a name="line-128"></a>                  <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"implic_eqs ="</span>       <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>implic_eqs</span>
<a name="line-129"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_implics ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-keyglyph'>]</span>
<a name="line-130"></a>
<a name="line-131"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>implic_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_implics</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-132"></a>
<a name="line-133"></a><a name="solveImplication"></a><span class='hs-definition'>solveImplication</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span>     <span class='hs-comment'>-- Untouchable TcS unification variables</span>
<a name="line-134"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Implication</span>    <span class='hs-comment'>-- Wanted</span>
<a name="line-135"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- All wanted or derived floated equalities: var = type</span>
<a name="line-136"></a>                         <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Unsolved rest (always empty or singleton)</span>
<a name="line-137"></a><span class='hs-comment'>-- Precondition: The TcS monad contains an empty worklist and given-only inerts </span>
<a name="line-138"></a><span class='hs-comment'>-- which after trying to solve this implication we must restore to their original value</span>
<a name="line-139"></a><span class='hs-definition'>solveImplication</span> <span class='hs-varid'>tcs_untouchables</span>
<a name="line-140"></a>     <span class='hs-varid'>imp</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_untch</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>untch</span>
<a name="line-141"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_binds</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_binds</span>
<a name="line-142"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_skols</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>skols</span> 
<a name="line-143"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_given</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>givens</span>
<a name="line-144"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wanteds</span>
<a name="line-145"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_loc</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-146"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>shadowIPs</span> <span class='hs-varid'>givens</span> <span class='hs-varop'>$</span>    <span class='hs-comment'>-- See Note [Shadowing of Implicit Parameters]</span>
<a name="line-147"></a>    <span class='hs-varid'>nestImplicTcS</span> <span class='hs-varid'>ev_binds</span> <span class='hs-layout'>(</span><span class='hs-varid'>untch</span><span class='hs-layout'>,</span> <span class='hs-varid'>tcs_untouchables</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-148"></a>    <span class='hs-varid'>recoverTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyBag</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-149"></a>       <span class='hs-comment'>-- Recover from nested failures.  Even the top level is</span>
<a name="line-150"></a>       <span class='hs-comment'>-- just a bunch of implications, so failing at the first one is bad</span>
<a name="line-151"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveImplication {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>imp</span><span class='hs-layout'>)</span> 
<a name="line-152"></a>
<a name="line-153"></a>         <span class='hs-comment'>-- Solve flat givens</span>
<a name="line-154"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>impls_from_givens</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveInteractGiven</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>givens</span> 
<a name="line-155"></a>       <span class='hs-layout'>;</span> <span class='hs-conid'>MASSERT</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>impls_from_givens</span><span class='hs-layout'>)</span>
<a name="line-156"></a>         
<a name="line-157"></a>         <span class='hs-comment'>-- Simplify the wanteds</span>
<a name="line-158"></a>       <span class='hs-layout'>;</span> <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-159"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsolved_implics</span>
<a name="line-160"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insols</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solve_wanteds</span> <span class='hs-varid'>wanteds</span>
<a name="line-161"></a>
<a name="line-162"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>res_flat_free</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_flat_bound</span><span class='hs-layout'>)</span>
<a name="line-163"></a>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>floatEqualities</span> <span class='hs-varid'>skols</span> <span class='hs-varid'>givens</span> <span class='hs-varid'>unsolved_flats</span>
<a name="line-164"></a>
<a name="line-165"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>res_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>res_flat_bound</span>
<a name="line-166"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsolved_implics</span>
<a name="line-167"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insols</span> <span class='hs-layout'>}</span>
<a name="line-168"></a>
<a name="line-169"></a>             <span class='hs-varid'>res_implic</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitImplication</span> <span class='hs-varop'>$</span>
<a name="line-170"></a>                          <span class='hs-varid'>imp</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>res_wanted</span>
<a name="line-171"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>ic_insol</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>res_wanted</span> <span class='hs-layout'>}</span>
<a name="line-172"></a>
<a name="line-173"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>evbinds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcEvBindsMap</span>
<a name="line-174"></a>
<a name="line-175"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveImplication end }"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-176"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"res_flat_free ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>res_flat_free</span>
<a name="line-177"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"implication evbinds = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>evBindMapBinds</span> <span class='hs-varid'>evbinds</span><span class='hs-layout'>)</span>
<a name="line-178"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"res_implic ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>res_implic</span> <span class='hs-keyglyph'>]</span>
<a name="line-179"></a>
<a name="line-180"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>res_flat_free</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_implic</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-181"></a>    <span class='hs-comment'>-- and we are back to the original inerts</span>
<a name="line-182"></a>
</pre>\end{code}


\begin{code}
<pre><a name="line-1"></a><a name="floatEqualities"></a><span class='hs-definition'>floatEqualities</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cts</span><span class='hs-layout'>)</span>
<a name="line-2"></a><span class='hs-comment'>-- Post: The returned FlavoredEvVar's are only Wanted or Derived</span>
<a name="line-3"></a><span class='hs-comment'>-- and come from the input wanted ev vars or deriveds </span>
<a name="line-4"></a><span class='hs-definition'>floatEqualities</span> <span class='hs-varid'>skols</span> <span class='hs-varid'>can_given</span> <span class='hs-varid'>wantders</span>
<a name="line-5"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>hasEqualities</span> <span class='hs-varid'>can_given</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>wantders</span><span class='hs-layout'>)</span>
<a name="line-6"></a>          <span class='hs-comment'>-- Note [Float Equalities out of Implications]</span>
<a name="line-7"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span> <span class='hs-varid'>is_floatable</span> <span class='hs-varid'>wantders</span>
<a name="line-8"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>skol_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>skols</span>
<a name="line-9"></a>        <span class='hs-varid'>is_floatable</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-10"></a>        <span class='hs-varid'>is_floatable</span> <span class='hs-varid'>ct</span>
<a name="line-11"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ct_predty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span>
<a name="line-12"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>isEqPred</span> <span class='hs-varid'>ct_predty</span>
<a name="line-13"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>skol_set</span> <span class='hs-varop'>`disjointVarSet`</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>ct_predty</span>
<a name="line-14"></a>        <span class='hs-varid'>is_floatable</span> <span class='hs-sel'>_ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-15"></a>
<a name="line-16"></a>        <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarSet</span>
<a name="line-17"></a>        <span class='hs-comment'>-- ^ NB: for type synonyms tvs_under_fsks does /not/ expand the synonym</span>
<a name="line-18"></a>        <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>     
<a name="line-19"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTcTyVar</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitVarSet</span> <span class='hs-varid'>tv</span>
<a name="line-20"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FlatSkol</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcTyVarDetails</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>ty</span>
<a name="line-21"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitVarSet</span> <span class='hs-varid'>tv</span>
<a name="line-22"></a>        <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unionVarSets</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-23"></a>        <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarSet</span>
<a name="line-24"></a>        <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>arg</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>res</span>
<a name="line-25"></a>        <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>arg</span>
<a name="line-26"></a>        <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- The kind of a coercion binder </span>
<a name="line-27"></a>        	     	       	        <span class='hs-comment'>-- can mention type variables!</span>
<a name="line-28"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>tv</span>		      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inner_tvs</span> <span class='hs-varop'>`delVarSet`</span> <span class='hs-varid'>tv</span>
<a name="line-29"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>{- Coercion -}</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- ASSERT( not (tv `elemVarSet` inner_tvs) )</span>
<a name="line-30"></a>                                        <span class='hs-varid'>inner_tvs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-31"></a>          <span class='hs-keyword'>where</span>
<a name="line-32"></a>            <span class='hs-varid'>inner_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs_under_fsks</span> <span class='hs-varid'>ty</span>
<a name="line-33"></a>
<a name="line-34"></a><a name="shadowIPs"></a><span class='hs-definition'>shadowIPs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-varid'>a</span>
<a name="line-35"></a><span class='hs-definition'>shadowIPs</span> <span class='hs-varid'>gs</span> <span class='hs-varid'>m</span>
<a name="line-36"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>shadowed</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m</span>
<a name="line-37"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>is</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span>
<a name="line-38"></a>                       <span class='hs-varid'>doWithInert</span> <span class='hs-layout'>(</span><span class='hs-varid'>purgeShadowed</span> <span class='hs-varid'>is</span><span class='hs-layout'>)</span> <span class='hs-varid'>m</span>
<a name="line-39"></a>  <span class='hs-keyword'>where</span>
<a name="line-40"></a>  <span class='hs-varid'>shadowed</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapMaybe</span> <span class='hs-varid'>isIP</span> <span class='hs-varid'>gs</span>
<a name="line-41"></a>
<a name="line-42"></a>  <span class='hs-varid'>isIP</span> <span class='hs-varid'>g</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>evVarPred_maybe</span> <span class='hs-varid'>g</span>
<a name="line-43"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isIPPred_maybe</span> <span class='hs-varid'>p</span>
<a name="line-44"></a>                 <span class='hs-varid'>return</span> <span class='hs-varid'>x</span>
<a name="line-45"></a>
<a name="line-46"></a>  <span class='hs-varid'>isShadowedCt</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isShadowedEv</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvidence</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-47"></a>  <span class='hs-varid'>isShadowedEv</span> <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>isIPPred_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-48"></a>                      <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>shadowed</span>
<a name="line-49"></a>                      <span class='hs-keyword'>_</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-50"></a>
<a name="line-51"></a>  <span class='hs-varid'>purgeShadowed</span> <span class='hs-varid'>is</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inert_cans</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>purgeCans</span> <span class='hs-layout'>(</span><span class='hs-varid'>inert_cans</span> <span class='hs-varid'>is</span><span class='hs-layout'>)</span>
<a name="line-52"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>inert_solved_dicts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>purgeSolved</span> <span class='hs-layout'>(</span><span class='hs-varid'>inert_solved_dicts</span> <span class='hs-varid'>is</span><span class='hs-layout'>)</span>
<a name="line-53"></a>                        <span class='hs-layout'>}</span>
<a name="line-54"></a>
<a name="line-55"></a>  <span class='hs-varid'>purgeDicts</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>.</span> <span class='hs-varid'>partitionCCanMap</span> <span class='hs-varid'>isShadowedCt</span>
<a name="line-56"></a>  <span class='hs-varid'>purgeCans</span> <span class='hs-varid'>ics</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ics</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inert_dicts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>purgeDicts</span> <span class='hs-layout'>(</span><span class='hs-varid'>inert_dicts</span> <span class='hs-varid'>ics</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-57"></a>  <span class='hs-varid'>purgeSolved</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterSolved</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>isShadowedEv</span><span class='hs-layout'>)</span>
</pre>\end{code}

Note [Preparing inert set for implications]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Before solving the nested implications, we convert any unsolved flat wanteds
to givens, and add them to the inert set.  Reasons:

  a) In checking mode, suppresses unnecessary errors.  We already have
     on unsolved-wanted error; adding it to the givens prevents any 
     consequential errors from showing up

  b) More importantly, in inference mode, we are going to quantify over this
     constraint, and we *don't* want to quantify over any constraints that
     are deducible from it.

  c) Flattened type-family equalities must be exposed to the nested
     constraints.  Consider
	F b ~ alpha, (forall c.  F b ~ alpha)
     Obviously this is soluble with [alpha := F b].  But the
     unification is only done by solveCTyFunEqs, right at the end of
     solveWanteds, and if we aren't careful we'll end up with an
     unsolved goal inside the implication.  We need to "push" the
     as-yes-unsolved (F b ~ alpha) inwards, as a *given*, so that it
     can be used to solve the inner (F b
     ~ alpha).  See Trac #4935.

  d) There are other cases where interactions between wanteds that can help
     to solve a constraint. For example

  	class C a b | a -> b

  	(C Int alpha), (forall d. C d blah => C Int a)

     If we push the (C Int alpha) inwards, as a given, it can produce
     a fundep (alpha~a) and this can float out again and be used to
     fix alpha.  (In general we can't float class constraints out just
     in case (C d blah) might help to solve (C Int a).)

The unsolved wanteds are *canonical* but they may not be *inert*,
because when made into a given they might interact with other givens.
Hence the call to solveInteract.  Example:

 Original inert set = (d :_g D a) /\ (co :_w  a ~ [beta]) 

We were not able to solve (a ~w [beta]) but we can't just assume it as
given because the resulting set is not inert. Hence we have to do a
'solveInteract' step first. 

Finally, note that we convert them to [Given] and NOT [Given/Solved].
The reason is that Given/Solved are weaker than Givens and may be discarded.
As an example consider the inference case, where we may have, the following 
original constraints: 
     [Wanted] F Int ~ Int
             (F Int ~ a => F Int ~ a)
If we convert F Int ~ Int to [Given/Solved] instead of Given, then the next 
given (F Int ~ a) is going to cause the Given/Solved to be ignored, casting 
the (F Int ~ a) insoluble. Hence we should really convert the residual 
wanteds to plain old Given. 

We need only push in unsolved equalities both in checking mode and inference mode: 

  (1) In checking mode we should not push given dictionaries in because of
example LongWayOverlapping.hs, where we might get strange overlap
errors between far-away constraints in the program.  But even in
checking mode, we must still push type family equations. Consider:

   type instance F True a b = a 
   type instance F False a b = b

   [w] F c a b ~ gamma 
   (c ~ True) => a ~ gamma 
   (c ~ False) => b ~ gamma

Since solveCTyFunEqs happens at the very end of solving, the only way to solve
the two implications is temporarily consider (F c a b ~ gamma) as Given (NB: not 
merely Given/Solved because it has to interact with the top-level instance 
environment) and push it inside the implications. Now, when we come out again at
the end, having solved the implications solveCTyFunEqs will solve this equality.

  (2) In inference mode, we recheck the final constraint in checking mode and
hence we will be able to solve inner implications from top-level quantified
constraints nonetheless.


Note [Extra TcsTv untouchables]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Whenever we are solving a bunch of flat constraints, they may contain 
the following sorts of 'touchable' unification variables:
   
   (i)   Born-touchables in that scope
 
   (ii)  Simplifier-generated unification variables, such as unification 
         flatten variables

   (iii) Touchables that have been floated out from some nested 
         implications, see Note [Float Equalities out of Implications]. 

Now, once we are done with solving these flats and have to move inwards to 
the nested implications (perhaps for a second time), we must consider all the
extra variables (categories (ii) and (iii) above) as untouchables for the 
implication. Otherwise we have the danger or double unifications, as well
as the danger of not ``seing'' some unification. Example (from Trac #4494):

   (F Int ~ uf)  /\  [untch=beta](forall a. C a => F Int ~ beta) 

In this example, beta is touchable inside the implication. The 
first solveInteract step leaves 'uf' ununified. Then we move inside 
the implication where a new constraint
       uf  ~  beta  
emerges. We may spontaneously solve it to get uf := beta, so the whole
implication disappears but when we pop out again we are left with (F
Int ~ uf) which will be unified by our final solveCTyFunEqs stage and
uf will get unified *once more* to (F Int).

The solution is to record the unification variables of the flats, 
and make them untouchables for the nested implication. In the 
example above uf would become untouchable, so beta would be forced 
to be unified as beta := uf.

Note [Float Equalities out of Implications]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
For ordinary pattern matches (including existentials) we float 
equalities out of implications, for instance: 
     data T where 
       MkT :: Eq a => a -> T 
     f x y = case x of MkT _ -> (y::Int)
We get the implication constraint (x::T) (y::alpha): 
     forall a. [untouchable=alpha] Eq a => alpha ~ Int
We want to float out the equality into a scope where alpha is no
longer untouchable, to solve the implication!  

But we cannot float equalities out of implications whose givens may
yield or contain equalities:

      data T a where 
        T1 :: T Int
        T2 :: T Bool
        T3 :: T a 
        
      h :: T a -> a -> Int
      
      f x y = case x of 
                T1 -> y::Int
                T2 -> y::Bool
                T3 -> h x y

We generate constraint, for (x::T alpha) and (y :: beta): 
   [untouchables = beta] (alpha ~ Int => beta ~ Int)   -- From 1st branch
   [untouchables = beta] (alpha ~ Bool => beta ~ Bool) -- From 2nd branch
   (alpha ~ beta)                                      -- From 3rd branch 

If we float the equality (beta ~ Int) outside of the first implication and 
the equality (beta ~ Bool) out of the second we get an insoluble constraint.
But if we just leave them inside the implications we unify alpha := beta and
solve everything.

Principle: 
    We do not want to float equalities out which may need the given *evidence*
    to become soluble.

Consequence: classes with functional dependencies don't matter (since there is 
no evidence for a fundep equality), but equality superclasses do matter (since 
they carry evidence).

Notice that, due to Note [Extra TcSTv Untouchables], the free unification variables 
of an equality that is floated out of an implication become effectively untouchables
for the leftover implication. This is absolutely necessary. Consider the following 
example. We start with two implications and a class with a functional dependency. 

class C x y | x -> y
instance C [a] [a]
      
(I1)      [untch=beta]forall b. 0 => F Int ~ [beta]
(I2)      [untch=beta]forall b. 0 => F Int ~ [[alpha]] /\ C beta [b]

We float (F Int ~ [beta]) out of I1, and we float (F Int ~ [[alpha]]) out of I2. 
They may react to yield that (beta := [alpha]) which can then be pushed inwards 
the leftover of I2 to get (C [alpha] [a]) which, using the FunDep, will mean that
(alpha := a). In the end we will have the skolem 'b' escaping in the untouchable
beta! Concrete example is in indexed_types/should_fail/ExtraTcsUntch.hs:

class C x y | x -> y where 
 op :: x -> y -> ()

instance C [a] [a]

type family F a :: *

h :: F Int -> ()
h = undefined

data TEx where 
  TEx :: a -> TEx 


f (x::beta) = 
    let g1 :: forall b. b -> ()
        g1 _ = h [x]
        g2 z = case z of TEx y -> (h [[undefined]], op x [y])
    in (g1 '3', g2 undefined)

Note [Shadowing of Implicit Parameters]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider the following example:

f :: (?x :: Char) => Char
f = let ?x = 'a' in ?x

The "let ?x = ..." generates an implication constraint of the form:

?x :: Char => ?x :: Char


Furthermore, the signature for `f` also generates an implication
constraint, so we end up with the following nested implication:

?x :: Char => (?x :: Char => ?x :: Char)

Note that the wanted (?x :: Char) constraint may be solved in
two incompatible ways:  either by using the parameter from the
signature, or by using the local definition.  Our intention is
that the local definition should "shadow" the parameter of the
signature, and we implement this as follows: when we nest implications,
we remove any implicit parameters in the outer implication, that
have the same name as givens of the inner implication.

Here is another variation of the example:

f :: (?x :: Int) => Char
f = let ?x = 'x' in ?x

This program should also be accepted: the two constraints `?x :: Int`
and `?x :: Char` never exist in the same context, so they don't get to
interact to cause failure.
\begin{code}
<pre><a name="line-1"></a>
<a name="line-2"></a>
<a name="line-3"></a>
<a name="line-4"></a><a name="unFlattenWC"></a><span class='hs-definition'>unFlattenWC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-5"></a><span class='hs-definition'>unFlattenWC</span> <span class='hs-varid'>wc</span> 
<a name="line-6"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>remaining_unsolved_flats</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveCTyFunEqs</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_flat</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-7"></a>                <span class='hs-comment'>-- See Note [Solving Family Equations]</span>
<a name="line-8"></a>                <span class='hs-comment'>-- NB: remaining_flats has already had subst applied</span>
<a name="line-9"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> 
<a name="line-10"></a>         <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>substCt</span> <span class='hs-varid'>subst</span><span class='hs-layout'>)</span> <span class='hs-varid'>remaining_unsolved_flats</span>
<a name="line-11"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>substImplication</span> <span class='hs-varid'>subst</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_impl</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span> 
<a name="line-12"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>substCt</span> <span class='hs-varid'>subst</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_insol</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-13"></a>       <span class='hs-layout'>}</span>
<a name="line-14"></a>  <span class='hs-keyword'>where</span> 
<a name="line-15"></a>    <span class='hs-varid'>solveCTyFunEqs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>TvSubst</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cts</span><span class='hs-layout'>)</span>
<a name="line-16"></a>    <span class='hs-comment'>-- Default equalities (F xi ~ alpha) by setting (alpha := F xi), whenever possible</span>
<a name="line-17"></a>    <span class='hs-comment'>-- See Note [Solving Family Equations]</span>
<a name="line-18"></a>    <span class='hs-comment'>-- Returns: a bunch of unsolved constraints from the original Cts and implications</span>
<a name="line-19"></a>    <span class='hs-comment'>--          where the newly generated equalities (alpha := F xi) have been substituted through.</span>
<a name="line-20"></a>    <span class='hs-varid'>solveCTyFunEqs</span> <span class='hs-varid'>cts</span>
<a name="line-21"></a>     <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>untch</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUntouchables</span> 
<a name="line-22"></a>          <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>unsolved_can_cts</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ni_subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>cv_binds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-23"></a>                    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getSolvableCTyFunEqs</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>cts</span>
<a name="line-24"></a>          <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"defaultCTyFunEqs"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"Trying to default family equations:"</span>
<a name="line-25"></a>                                              <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ni_subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cv_binds</span>
<a name="line-26"></a>                                              <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-27"></a>          <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-varid'>solve_one</span> <span class='hs-varid'>cv_binds</span>
<a name="line-28"></a>
<a name="line-29"></a>          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>niFixTvSubst</span> <span class='hs-varid'>ni_subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_can_cts</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-30"></a>      <span class='hs-keyword'>where</span>
<a name="line-31"></a>        <span class='hs-varid'>solve_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>Wanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_evar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cv</span> <span class='hs-layout'>}</span><span class='hs-layout'>,</span> <span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> 
<a name="line-32"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setWantedTyBind</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>setEvBind</span> <span class='hs-varid'>cv</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcReflCo</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-33"></a>        <span class='hs-varid'>solve_one</span> <span class='hs-layout'>(</span><span class='hs-conid'>Derived</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>,</span> <span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-34"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setWantedTyBind</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty</span>
<a name="line-35"></a>        <span class='hs-varid'>solve_one</span> <span class='hs-varid'>arg</span>
<a name="line-36"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"solveCTyFunEqs: can't solve a /given/ family equation!"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg</span>
<a name="line-37"></a>
<a name="line-38"></a><a name="FunEqBinds"></a><span class='hs-comment'>------------</span>
<a name="line-39"></a><a name="FunEqBinds"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>FunEqBinds</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>TvSubstEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>CtEvidence</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTyVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcType</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-40"></a>  <span class='hs-comment'>-- The TvSubstEnv is not idempotent, but is loop-free</span>
<a name="line-41"></a>  <span class='hs-comment'>-- See Note [Non-idempotent substitution] in Unify</span>
<a name="line-42"></a><a name="emptyFunEqBinds"></a><span class='hs-definition'>emptyFunEqBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FunEqBinds</span>
<a name="line-43"></a><span class='hs-definition'>emptyFunEqBinds</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyVarEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-44"></a>
<a name="line-45"></a><a name="extendFunEqBinds"></a><span class='hs-definition'>extendFunEqBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FunEqBinds</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FunEqBinds</span>
<a name="line-46"></a><span class='hs-definition'>extendFunEqBinds</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv_subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>cv_binds</span><span class='hs-layout'>)</span> <span class='hs-varid'>fl</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty</span>
<a name="line-47"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendVarEnv</span> <span class='hs-varid'>tv_subst</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>fl</span><span class='hs-layout'>,</span> <span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>cv_binds</span><span class='hs-layout'>)</span>
<a name="line-48"></a>
<a name="line-49"></a><a name="getSolvableCTyFunEqs"></a><span class='hs-comment'>------------</span>
<a name="line-50"></a><span class='hs-definition'>getSolvableCTyFunEqs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcsUntouchables</span>
<a name="line-51"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>                <span class='hs-comment'>-- Precondition: all Wanteds or Derived!</span>
<a name="line-52"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>FunEqBinds</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Postcondition: returns the unsolvables</span>
<a name="line-53"></a><span class='hs-definition'>getSolvableCTyFunEqs</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>cts</span>
<a name="line-54"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Bag</span><span class='hs-varop'>.</span><span class='hs-varid'>foldlBag</span> <span class='hs-varid'>dflt_funeq</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyCts</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyFunEqBinds</span><span class='hs-layout'>)</span> <span class='hs-varid'>cts</span>
<a name="line-55"></a>  <span class='hs-keyword'>where</span>
<a name="line-56"></a>    <span class='hs-varid'>dflt_funeq</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>FunEqBinds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span>
<a name="line-57"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>FunEqBinds</span><span class='hs-layout'>)</span>
<a name="line-58"></a>    <span class='hs-varid'>dflt_funeq</span> <span class='hs-layout'>(</span><span class='hs-varid'>cts_in</span><span class='hs-layout'>,</span> <span class='hs-varid'>feb</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>tv_subst</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-59"></a>               <span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fl</span>
<a name="line-60"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>cc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc</span>
<a name="line-61"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span>
<a name="line-62"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-63"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>xi</span>      <span class='hs-comment'>-- RHS is a type variable</span>
<a name="line-64"></a>
<a name="line-65"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isTouchableMetaTyVar_InRange</span> <span class='hs-varid'>untch</span> <span class='hs-varid'>tv</span>
<a name="line-66"></a>           <span class='hs-comment'>-- And it's a *touchable* unification variable</span>
<a name="line-67"></a>
<a name="line-68"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>xi</span> <span class='hs-varop'>`tcIsSubKind`</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span>
<a name="line-69"></a>         <span class='hs-comment'>-- Must do a small kind check since TcCanonical invariants </span>
<a name="line-70"></a>         <span class='hs-comment'>-- on family equations only impose compatibility, not subkinding</span>
<a name="line-71"></a>
<a name="line-72"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarEnv`</span> <span class='hs-varid'>tv_subst</span><span class='hs-layout'>)</span>
<a name="line-73"></a>           <span class='hs-comment'>-- Check not in extra_binds</span>
<a name="line-74"></a>           <span class='hs-comment'>-- See Note [Solving Family Equations], Point 1</span>
<a name="line-75"></a>
<a name="line-76"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>niSubstTvSet</span> <span class='hs-varid'>tv_subst</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>xis</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-77"></a>           <span class='hs-comment'>-- Occurs check: see Note [Solving Family Equations], Point 2</span>
<a name="line-78"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span> <span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isGiven</span> <span class='hs-varid'>fl</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-79"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>cts_in</span><span class='hs-layout'>,</span> <span class='hs-varid'>extendFunEqBinds</span> <span class='hs-varid'>feb</span> <span class='hs-varid'>fl</span> <span class='hs-varid'>tv</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-80"></a>
<a name="line-81"></a>    <span class='hs-varid'>dflt_funeq</span> <span class='hs-layout'>(</span><span class='hs-varid'>cts_in</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_eq_binds</span><span class='hs-layout'>)</span> <span class='hs-varid'>ct</span>
<a name="line-82"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>cts_in</span> <span class='hs-varop'>`extendCts`</span> <span class='hs-varid'>ct</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_eq_binds</span><span class='hs-layout'>)</span>
</pre>\end{code}

Note [Solving Family Equations] 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
After we are done with simplification we may be left with constraints of the form:
     [Wanted] F xis ~ beta 
If 'beta' is a touchable unification variable not already bound in the TyBinds 
then we'd like to create a binding for it, effectively "defaulting" it to be 'F xis'.

When is it ok to do so? 
    1) 'beta' must not already be defaulted to something. Example: 

           [Wanted] F Int  ~ beta   <~ Will default [beta := F Int]
           [Wanted] F Char ~ beta   <~ Already defaulted, can't default again. We 
                                       have to report this as unsolved.

    2) However, we must still do an occurs check when defaulting (F xis ~ beta), to 
       set [beta := F xis] only if beta is not among the free variables of xis.

    3) Notice that 'beta' can't be bound in ty binds already because we rewrite RHS 
       of type family equations. See Inert Set invariants in TcInteract. 


*********************************************************************************
*                                                                               * 
*                          Defaulting and disamgiguation                        *
*                                                                               *
*********************************************************************************
\begin{code}
<pre><a name="line-1"></a><a name="applyDefaultingRules"></a><span class='hs-definition'>applyDefaultingRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Cts</span>      <span class='hs-comment'>-- Wanteds or Deriveds</span>
<a name="line-2"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>  <span class='hs-comment'>-- Derived equalities </span>
<a name="line-3"></a><span class='hs-comment'>-- Return some extra derived equalities, which express the</span>
<a name="line-4"></a><span class='hs-comment'>-- type-class default choice. </span>
<a name="line-5"></a><span class='hs-definition'>applyDefaultingRules</span> <span class='hs-varid'>wanteds</span>
<a name="line-6"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>wanteds</span> 
<a name="line-7"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>emptyBag</span>
<a name="line-8"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-9"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"applyDefaultingRules { "</span> <span class='hs-varop'>$</span> 
<a name="line-10"></a>                  <span class='hs-varid'>text</span> <span class='hs-str'>"wanteds ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span>
<a name="line-11"></a>                  
<a name="line-12"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>info</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>default_tys</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDefaultInfo</span>
<a name="line-13"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>groups</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findDefaultableGroups</span> <span class='hs-varid'>info</span> <span class='hs-varid'>wanteds</span>
<a name="line-14"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"findDefaultableGroups"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"groups="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>groups</span>
<a name="line-15"></a>                                                 <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"info="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>info</span> <span class='hs-keyglyph'>]</span>
<a name="line-16"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>deflt_cts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>disambigGroup</span> <span class='hs-varid'>default_tys</span><span class='hs-layout'>)</span> <span class='hs-varid'>groups</span>
<a name="line-17"></a>
<a name="line-18"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"applyDefaultingRules }"</span> <span class='hs-varop'>$</span> 
<a name="line-19"></a>                  <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Type defaults ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>deflt_cts</span><span class='hs-keyglyph'>]</span>
<a name="line-20"></a>
<a name="line-21"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>unionManyBags</span> <span class='hs-varid'>deflt_cts</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
</pre>\end{code}

Note [tryTcS in defaulting]
~~~~~~~~~~~~~~~~~~~~~~~~~~~

defaultTyVar and disambigGroup create new evidence variables for
default equations, and hence update the EvVar cache. However, after
applyDefaultingRules we will try to solve these default equations
using solveInteractCts, which will consult the cache and solve those
EvVars from themselves! That's wrong.

To avoid this problem we guard defaulting under a @tryTcS@ which leaves
the original cache unmodified.

There is a second reason for @tryTcS@ in defaulting: disambGroup does
some constraint solving to determine if a default equation is
``useful'' in solving some wanted constraints, but we want to
discharge all evidence and unifications that may have happened during
this constraint solving.

Finally, @tryTcS@ importantly does not inherit the original cache from
the higher level but makes up a new cache, the reason is that disambigGroup
will call solveInteractCts so the new derived and the wanteds must not be 
in the cache!


\begin{code}
<pre><a name="line-1"></a><a name="touchablesOfWC"></a><span class='hs-comment'>------------------</span>
<a name="line-2"></a><span class='hs-definition'>touchablesOfWC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVarSet</span>
<a name="line-3"></a><span class='hs-comment'>-- See Note [Extra Tcs Untouchables] to see why we carry a TcsUntouchables </span>
<a name="line-4"></a><span class='hs-comment'>-- instead of just using the Untouchable range have in our hands.</span>
<a name="line-5"></a><span class='hs-definition'>touchablesOfWC</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>NoUntouchables</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyVarSet</span><span class='hs-layout'>)</span>
<a name="line-6"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcsUntouchables</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVarSet</span>
<a name="line-7"></a>        <span class='hs-varid'>go</span> <span class='hs-varid'>untch</span> <span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flats</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>impls</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> 
<a name="line-8"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterVarSet</span> <span class='hs-varid'>is_touchable</span> <span class='hs-varid'>flat_tvs</span> <span class='hs-varop'>`unionVarSet`</span>
<a name="line-9"></a>              <span class='hs-varid'>foldrBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>unionVarSet</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>go_impl</span> <span class='hs-varop'>$</span> <span class='hs-varid'>untch_for_impls</span> <span class='hs-varid'>untch</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>impls</span> 
<a name="line-10"></a>          <span class='hs-keyword'>where</span> <span class='hs-varid'>is_touchable</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isTouchableMetaTyVar_InRange</span> <span class='hs-varid'>untch</span>
<a name="line-11"></a>                <span class='hs-varid'>flat_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfCts</span> <span class='hs-varid'>flats</span>
<a name="line-12"></a>                <span class='hs-varid'>untch_for_impls</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span><span class='hs-layout'>,</span><span class='hs-varid'>uset</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-varid'>uset</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>flat_tvs</span><span class='hs-layout'>)</span>
<a name="line-13"></a>        <span class='hs-varid'>go_impl</span> <span class='hs-layout'>(</span><span class='hs-sel'>_rng</span><span class='hs-layout'>,</span><span class='hs-varid'>set</span><span class='hs-layout'>)</span> <span class='hs-varid'>implic</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>ic_untch</span> <span class='hs-varid'>implic</span><span class='hs-layout'>,</span><span class='hs-varid'>set</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ic_wanted</span> <span class='hs-varid'>implic</span><span class='hs-layout'>)</span>
<a name="line-14"></a>
<a name="line-15"></a><a name="applyTyVarDefaulting"></a><span class='hs-definition'>applyTyVarDefaulting</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>Cts</span>
<a name="line-16"></a><span class='hs-definition'>applyTyVarDefaulting</span> <span class='hs-varid'>wc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runTcS</span> <span class='hs-varid'>do_dflt</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span>
<a name="line-17"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>do_dflt</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tv_cts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>defaultTyVar</span> <span class='hs-varop'>$</span> 
<a name="line-18"></a>                                 <span class='hs-varid'>varSetElems</span> <span class='hs-layout'>(</span><span class='hs-varid'>touchablesOfWC</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-19"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>unionManyBags</span> <span class='hs-varid'>tv_cts</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-20"></a>
<a name="line-21"></a><a name="defaultTyVar"></a><span class='hs-definition'>defaultTyVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-22"></a><span class='hs-comment'>-- Precondition: a touchable meta-variable</span>
<a name="line-23"></a><span class='hs-definition'>defaultTyVar</span> <span class='hs-varid'>the_tv</span>
<a name="line-24"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>k</span> <span class='hs-varop'>`eqKind`</span> <span class='hs-varid'>default_k</span><span class='hs-layout'>)</span>
<a name="line-25"></a>  <span class='hs-comment'>-- Why tryTcS? See Note [tryTcS in defaulting]</span>
<a name="line-26"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tryTcS</span> <span class='hs-varop'>$</span>
<a name="line-27"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CtLoc</span> <span class='hs-conid'>DefaultOrigin</span> <span class='hs-layout'>(</span><span class='hs-varid'>getSrcSpan</span> <span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-comment'>-- Yuk</span>
<a name="line-28"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ty_k</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>instFlexiTcSHelperTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarName</span> <span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span> <span class='hs-varid'>default_k</span>
<a name="line-29"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>md</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newDerived</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcEqPred</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty_k</span><span class='hs-layout'>)</span>
<a name="line-30"></a>             <span class='hs-comment'>-- Why not directly newDerived loc (mkTcEqPred k default_k)? </span>
<a name="line-31"></a>             <span class='hs-comment'>-- See Note [DefaultTyVar]</span>
<a name="line-32"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>cts</span>
<a name="line-33"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>der_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>md</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>der_ev</span><span class='hs-keyglyph'>]</span>
<a name="line-34"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-35"></a>       
<a name="line-36"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>implics_from_defaulting</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveInteractCts</span> <span class='hs-varid'>cts</span>
<a name="line-37"></a>       <span class='hs-layout'>;</span> <span class='hs-conid'>MASSERT</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>implics_from_defaulting</span><span class='hs-layout'>)</span>
<a name="line-38"></a>         
<a name="line-39"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unsolved</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-varop'>.</span> <span class='hs-varid'>getInertUnsolved</span><span class='hs-layout'>)</span>
<a name="line-40"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>keepWanted</span> <span class='hs-varid'>unsolved</span><span class='hs-layout'>)</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>listToBag</span> <span class='hs-varid'>cts</span><span class='hs-layout'>)</span>
<a name="line-41"></a>         <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-varid'>emptyBag</span> <span class='hs-layout'>}</span>
<a name="line-42"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>emptyBag</span>	 <span class='hs-comment'>-- The common case</span>
<a name="line-43"></a>  <span class='hs-keyword'>where</span>
<a name="line-44"></a>    <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>the_tv</span>
<a name="line-45"></a>    <span class='hs-varid'>default_k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>defaultKind</span> <span class='hs-varid'>k</span>
</pre>\end{code}

Note [DefaultTyVar]
~~~~~~~~~~~~~~~~~~~
defaultTyVar is used on any un-instantiated meta type variables to
default the kind of OpenKind and ArgKind etc to *.  This is important 
to ensure that instance declarations match.  For example consider

     instance Show (a->b)
     foo x = show (\_ -> True)

Then we'll get a constraint (Show (p ->q)) where p has kind ArgKind,
and that won't match the typeKind (*) in the instance decl.  See tests
tc217 and tc175.

We look only at touchable type variables. No further constraints
are going to affect these type variables, so it's time to do it by
hand.  However we aren't ready to default them fully to () or
whatever, because the type-class defaulting rules have yet to run.

An important point is that if the type variable tv has kind k and the
default is default_k we do not simply generate [D] (k ~ default_k) because:

   (1) k may be ArgKind and default_k may be * so we will fail

   (2) We need to rewrite all occurrences of the tv to be a type
       variable with the right kind and we choose to do this by rewriting 
       the type variable /itself/ by a new variable which does have the 
       right kind.

\begin{code}
<pre><a name="line-1"></a>
<a name="line-2"></a>
<a name="line-3"></a><a name="findDefaultableGroups"></a><span class='hs-comment'>----------------</span>
<a name="line-4"></a><span class='hs-definition'>findDefaultableGroups</span> 
<a name="line-5"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-6"></a>       <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span><span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>  <span class='hs-comment'>-- (Overloaded strings, extended default rules)</span>
<a name="line-7"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>	        <span class='hs-comment'>-- Unsolved (wanted or derived)</span>
<a name="line-8"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span><span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<a name="line-9"></a><span class='hs-definition'>findDefaultableGroups</span> <span class='hs-layout'>(</span><span class='hs-varid'>default_tys</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span><span class='hs-layout'>,</span> <span class='hs-varid'>extended_defaults</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>wanteds</span>
<a name="line-10"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>default_tys</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-11"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>is_defaultable_group</span> <span class='hs-layout'>(</span><span class='hs-varid'>equivClasses</span> <span class='hs-varid'>cmp_tv</span> <span class='hs-varid'>unaries</span><span class='hs-layout'>)</span>
<a name="line-12"></a>  <span class='hs-keyword'>where</span> 
<a name="line-13"></a>    <span class='hs-varid'>unaries</span>     <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- (C tv) constraints</span>
<a name="line-14"></a>    <span class='hs-varid'>non_unaries</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>             <span class='hs-comment'>-- and *other* constraints</span>
<a name="line-15"></a>    
<a name="line-16"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>unaries</span><span class='hs-layout'>,</span> <span class='hs-varid'>non_unaries</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionWith</span> <span class='hs-varid'>find_unary</span> <span class='hs-layout'>(</span><span class='hs-varid'>bagToList</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-17"></a>        <span class='hs-comment'>-- Finds unary type-class constraints</span>
<a name="line-18"></a>    <span class='hs-varid'>find_unary</span> <span class='hs-varid'>cc</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ty</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-19"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-20"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-21"></a>    <span class='hs-varid'>find_unary</span> <span class='hs-varid'>cc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>cc</span>  <span class='hs-comment'>-- Non unary or non dictionary </span>
<a name="line-22"></a>
<a name="line-23"></a>    <span class='hs-varid'>bad_tvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span>  <span class='hs-comment'>-- TyVars mentioned by non-unaries </span>
<a name="line-24"></a>    <span class='hs-varid'>bad_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>unionVarSet</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tyVarsOfCt</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>non_unaries</span> 
<a name="line-25"></a>
<a name="line-26"></a>    <span class='hs-varid'>cmp_tv</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv1</span> <span class='hs-varop'>`compare`</span> <span class='hs-varid'>tv2</span>
<a name="line-27"></a>
<a name="line-28"></a>    <span class='hs-varid'>is_defaultable_group</span> <span class='hs-varid'>ds</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-29"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>b1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isTyConableTyVar</span> <span class='hs-varid'>tv</span>	<span class='hs-comment'>-- Note [Avoiding spurious errors]</span>
<a name="line-30"></a>              <span class='hs-varid'>b2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>bad_tvs</span><span class='hs-layout'>)</span>
<a name="line-31"></a>              <span class='hs-varid'>b4</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>defaultable_classes</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>cc_class</span> <span class='hs-varid'>cc</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ds</span><span class='hs-keyglyph'>]</span>
<a name="line-32"></a>          <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>b1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>b2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>b4</span><span class='hs-layout'>)</span>
<a name="line-33"></a>    <span class='hs-varid'>is_defaultable_group</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"defaultable_group"</span>
<a name="line-34"></a>
<a name="line-35"></a>    <span class='hs-varid'>defaultable_classes</span> <span class='hs-varid'>clss</span> 
<a name="line-36"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>extended_defaults</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-varid'>isInteractiveClass</span> <span class='hs-varid'>clss</span>
<a name="line-37"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-varid'>is_std_class</span> <span class='hs-varid'>clss</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>any</span> <span class='hs-varid'>is_num_class</span> <span class='hs-varid'>clss</span><span class='hs-layout'>)</span>
<a name="line-38"></a>
<a name="line-39"></a>    <span class='hs-comment'>-- In interactive mode, or with -XExtendedDefaultRules,</span>
<a name="line-40"></a>    <span class='hs-comment'>-- we default Show a to Show () to avoid graututious errors on "show []"</span>
<a name="line-41"></a>    <span class='hs-varid'>isInteractiveClass</span> <span class='hs-varid'>cls</span> 
<a name="line-42"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_num_class</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>classKey</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>showClassKey</span><span class='hs-layout'>,</span> <span class='hs-varid'>eqClassKey</span><span class='hs-layout'>,</span> <span class='hs-varid'>ordClassKey</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-43"></a>
<a name="line-44"></a>    <span class='hs-varid'>is_num_class</span> <span class='hs-varid'>cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNumericClass</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>isStringClassKey</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-45"></a>    <span class='hs-comment'>-- is_num_class adds IsString to the standard numeric classes, </span>
<a name="line-46"></a>    <span class='hs-comment'>-- when -foverloaded-strings is enabled</span>
<a name="line-47"></a>
<a name="line-48"></a>    <span class='hs-varid'>is_std_class</span> <span class='hs-varid'>cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isStandardClass</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>isStringClassKey</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-49"></a>    <span class='hs-comment'>-- Similarly is_std_class</span>
<a name="line-50"></a>
<a name="line-51"></a><a name="disambigGroup"></a><span class='hs-comment'>------------------------------</span>
<a name="line-52"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>           <span class='hs-comment'>-- The default types </span>
<a name="line-53"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- All classes of the form (C a)</span>
<a name="line-54"></a>	      	 		  <span class='hs-comment'>--  sharing same type variable</span>
<a name="line-55"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-56"></a>
<a name="line-57"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-conid'>[]</span>  <span class='hs-sel'>_grp</span>
<a name="line-58"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>emptyBag</span>
<a name="line-59"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>default_ty</span><span class='hs-conop'>:</span><span class='hs-varid'>default_tys</span><span class='hs-layout'>)</span> <span class='hs-varid'>group</span>
<a name="line-60"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>group</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-61"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>success</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tryTcS</span> <span class='hs-varop'>$</span> <span class='hs-comment'>-- Why tryTcS? See Note [tryTcS in defaulting]</span>
<a name="line-62"></a>                    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>derived_eq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tryTcS</span> <span class='hs-varop'>$</span> 
<a name="line-63"></a>                       <span class='hs-comment'>-- I need a new tryTcS because we will call solveInteractCts below!</span>
<a name="line-64"></a>                            <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>md</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newDerived</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctev_wloc</span> <span class='hs-varid'>the_fl</span><span class='hs-layout'>)</span> 
<a name="line-65"></a>                                                  <span class='hs-layout'>(</span><span class='hs-varid'>mkTcEqPred</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-66"></a>                                                  <span class='hs-comment'>-- ctev_wloc because constraint is not Given!</span>
<a name="line-67"></a>                               <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>md</span> <span class='hs-keyword'>of</span> 
<a name="line-68"></a>                                    <span class='hs-conid'>Nothing</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span>
<a name="line-69"></a>                                    <span class='hs-conid'>Just</span> <span class='hs-varid'>ctev</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>ctev</span> <span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span>
<a name="line-70"></a>                            
<a name="line-71"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup (solving) {"</span> <span class='hs-varop'>$</span>
<a name="line-72"></a>                         <span class='hs-varid'>text</span> <span class='hs-str'>"trying to solve constraints along with default equations ..."</span>
<a name="line-73"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>implics_from_defaulting</span> <span class='hs-keyglyph'>&lt;-</span> 
<a name="line-74"></a>                                    <span class='hs-varid'>solveInteractCts</span> <span class='hs-layout'>(</span><span class='hs-varid'>derived_eq</span> <span class='hs-varop'>++</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-75"></a>                       <span class='hs-layout'>;</span> <span class='hs-conid'>MASSERT</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>implics_from_defaulting</span><span class='hs-layout'>)</span>
<a name="line-76"></a>                           <span class='hs-comment'>-- I am not certain if any implications can be generated</span>
<a name="line-77"></a>                           <span class='hs-comment'>-- but I am letting this fail aggressively if this ever happens.</span>
<a name="line-78"></a>                                     
<a name="line-79"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>unsolved</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-varop'>.</span> <span class='hs-varid'>getInertUnsolved</span><span class='hs-layout'>)</span>  
<a name="line-80"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup (solving) }"</span> <span class='hs-varop'>$</span>
<a name="line-81"></a>                         <span class='hs-varid'>text</span> <span class='hs-str'>"disambigGroup unsolved ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>keepWanted</span> <span class='hs-varid'>unsolved</span><span class='hs-layout'>)</span>
<a name="line-82"></a>                       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>keepWanted</span> <span class='hs-varid'>unsolved</span><span class='hs-layout'>)</span> <span class='hs-keyword'>then</span> <span class='hs-comment'>-- Don't care about Derived's</span>
<a name="line-83"></a>                             <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varop'>$</span> <span class='hs-varid'>listToBag</span> <span class='hs-varid'>derived_eq</span><span class='hs-layout'>)</span> 
<a name="line-84"></a>                         <span class='hs-keyword'>else</span> 
<a name="line-85"></a>                             <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span> 
<a name="line-86"></a>                       <span class='hs-layout'>}</span>
<a name="line-87"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>success</span> <span class='hs-keyword'>of</span>
<a name="line-88"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- Success: record the type variable binding, and return</span>
<a name="line-89"></a>                    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wrapWarnTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>warnDefaulting</span> <span class='hs-varid'>wanteds</span> <span class='hs-varid'>default_ty</span>
<a name="line-90"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup succeeded"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-91"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>cts</span> <span class='hs-layout'>}</span>
<a name="line-92"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- Failure: try with the next type</span>
<a name="line-93"></a>                    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup failed, will try other default types"</span>
<a name="line-94"></a>                                  <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-95"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>disambigGroup</span> <span class='hs-varid'>default_tys</span> <span class='hs-varid'>group</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-96"></a>  <span class='hs-keyword'>where</span>
<a name="line-97"></a>    <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>the_ct</span><span class='hs-layout'>,</span><span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>group</span>
<a name="line-98"></a>    <span class='hs-varid'>the_fl</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cc_ev</span> <span class='hs-varid'>the_ct</span>
<a name="line-99"></a>    <span class='hs-varid'>wanteds</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>group</span>
</pre>\end{code}

Note [Avoiding spurious errors]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When doing the unification for defaulting, we check for skolem
type variables, and simply don't default them.  For example:
   f = (*)	-- Monomorphic
   g :: Num a => a -> a
   g x = f x x
Here, we get a complaint when checking the type signature for g,
that g isn't polymorphic enough; but then we get another one when
dealing with the (Num a) context arising from f's definition;
we try to unify a with Int (to default it), but find that it's
already been unified with the rigid variable from g's type sig



*********************************************************************************
*                                                                               * 
*                   Utility functions
*                                                                               *
*********************************************************************************

\begin{code}
<pre><a name="line-1"></a><a name="newFlatWanteds"></a><span class='hs-definition'>newFlatWanteds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtOrigin</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>
<a name="line-2"></a><span class='hs-definition'>newFlatWanteds</span> <span class='hs-varid'>orig</span> <span class='hs-varid'>theta</span>
<a name="line-3"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getCtLoc</span> <span class='hs-varid'>orig</span>
<a name="line-4"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>inst_to_wanted</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span> <span class='hs-varid'>theta</span> <span class='hs-layout'>}</span>
<a name="line-5"></a>  <span class='hs-keyword'>where</span> 
<a name="line-6"></a>    <span class='hs-varid'>inst_to_wanted</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>pty</span> 
<a name="line-7"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcMType</span><span class='hs-varop'>.</span><span class='hs-varid'>newWantedEvVar</span> <span class='hs-varid'>pty</span> 
<a name="line-8"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> 
<a name="line-9"></a>                 <span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Wanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_evar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v</span>
<a name="line-10"></a>                                                <span class='hs-layout'>,</span> <span class='hs-varid'>ctev_wloc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span>
<a name="line-11"></a>                                                <span class='hs-layout'>,</span> <span class='hs-varid'>ctev_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pty</span> <span class='hs-layout'>}</span>
<a name="line-12"></a>                               <span class='hs-layout'>,</span> <span class='hs-varid'>cc_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
</pre>\end{code}
</body>
</html>
